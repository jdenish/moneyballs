<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Jordan's Moneyballs</title>
  <script src="https://unpkg.com/react@18/umd/react.production.min.js"></script>
  <script src="https://unpkg.com/react-dom@18/umd/react-dom.production.min.js"></script>
  <script src="https://unpkg.com/@babel/standalone/babel.min.js"></script>
  <script src="https://cdn.tailwindcss.com"></script>
  <script src="https://unpkg.com/pako@2.1.0/dist/pako.min.js"></script>
</head>
<body>
  <div id="root"></div>
  <script type="text/babel">
    const { useState, useMemo, useCallback, memo } = React;

    // Move components outside App to prevent recreation on each render

    const SeedingMatch = memo(({ match, score, isOnCourt, onScoreChange, onToggleCourt, readOnly }) => {
      const isComplete = score.s1 !== undefined && score.s2 !== undefined && score.s1 !== '' && score.s2 !== '';
      const t1Won = isComplete && parseInt(score.s1) > parseInt(score.s2);
      const t2Won = isComplete && parseInt(score.s2) > parseInt(score.s1);

      return (
        <div className={`p-2 rounded border ${isComplete ? 'bg-gray-800 border-green-600' : isOnCourt ? 'bg-orange-900/50 border-orange-500' : 'bg-gray-800 border-gray-600'}`}>
          <div className="flex justify-between items-center mb-1">
            <span className="text-gray-500 text-xs">Court {match.court}</span>
            {!isComplete && !readOnly && (
              <button
                onClick={onToggleCourt}
                className={`text-xs px-2 py-0.5 rounded ${isOnCourt ? 'bg-orange-600' : 'bg-gray-700 hover:bg-orange-700'}`}
              >
                {isOnCourt ? 'üèì On Court' : 'Send'}
              </button>
            )}
          </div>
          <div className={`flex items-center gap-2 ${t1Won ? 'text-green-400' : 'text-gray-300'}`}>
            <span className="text-xs bg-gray-700 px-1 rounded">{match.t1.seed}</span>
            <span className="flex-1 text-sm truncate">{match.t1.name}</span>
            {readOnly ? (
              <span className="w-12 text-center text-sm font-mono">{score.s1 || '-'}</span>
            ) : (
              <input
                type="number"
                className="w-12 bg-gray-700 text-center rounded text-sm"
                value={score.s1 || ''}
                onChange={(e) => onScoreChange('s1', e.target.value)}
              />
            )}
          </div>
          <div className={`flex items-center gap-2 mt-1 ${t2Won ? 'text-green-400' : 'text-gray-300'}`}>
            <span className="text-xs bg-gray-700 px-1 rounded">{match.t2.seed}</span>
            <span className="flex-1 text-sm truncate">{match.t2.name}</span>
            {readOnly ? (
              <span className="w-12 text-center text-sm font-mono">{score.s2 || '-'}</span>
            ) : (
              <input
                type="number"
                className="w-12 bg-gray-700 text-center rounded text-sm"
                value={score.s2 || ''}
                onChange={(e) => onScoreChange('s2', e.target.value)}
              />
            )}
          </div>
        </div>
      );
    });

    const BracketMatch = memo(({ match, score, override, isOnCourt, showOverride, onScoreChange, onBo3ScoreChange, onToggleCourt, onOverride, onClearOverride, winner, readOnly }) => {
      if (!match) return null;
      const t1 = match.t1;
      const t2 = match.t2;
      const isReady = t1 && t2;
      const hasBo3Games = score.games && score.games.length > 0;

      // Bo3 completion logic
      let bo3T1Wins = 0, bo3T2Wins = 0;
      if (hasBo3Games) {
        score.games.forEach(g => {
          const s1v = parseInt(g.s1), s2v = parseInt(g.s2);
          if (!isNaN(s1v) && !isNaN(s2v)) { if (s1v > s2v) bo3T1Wins++; else if (s2v > s1v) bo3T2Wins++; }
        });
      }
      const bo3Complete = bo3T1Wins >= 2 || bo3T2Wins >= 2;

      // How many game inputs to show for Bo3
      const numBo3Games = (() => {
        if (!match.bo3 || readOnly || override || !isReady) return 0;
        const games = score.games || [];
        if (bo3Complete) return games.length;
        if (games.length === 0) return 1;
        const allDone = games.every(g => g.s1 !== '' && g.s2 !== '' && g.s1 !== undefined && g.s2 !== undefined && parseInt(g.s1) !== parseInt(g.s2));
        if (allDone) return Math.min(games.length + 1, 3);
        return games.length;
      })();
      const isBo3Input = match.bo3 && !readOnly && isReady && !override;

      const isComplete = override || (isReady && (
        (match.bo3 ? bo3Complete : false) ||
        (!match.bo3 && score.s1 !== undefined && score.s2 !== undefined && score.s1 !== '' && score.s2 !== '')
      ));
      const t1Won = winner && t1 && winner.seed === t1.seed;
      const t2Won = winner && t2 && winner.seed === t2.seed;

      return (
        <div className={`p-2 rounded border ${isComplete ? 'bg-gray-800 border-green-600' : isOnCourt ? 'bg-orange-900/50 border-orange-500' : isReady ? 'bg-gray-800 border-yellow-500' : 'bg-gray-800 border-gray-700'} ${match.bo3 ? 'ring-2 ring-yellow-500' : ''}`}>
          <div className="text-xs text-gray-500 mb-1 flex justify-between">
            <span>{match.round}</span>
            <div className="flex gap-1 items-center">
              {match.bo3 && <span className="text-yellow-400">Bo3</span>}
              {override && !readOnly && <span className="text-orange-400 cursor-pointer" onClick={onClearOverride}>‚ü≤</span>}
              {isReady && !isComplete && !readOnly && (
                <button
                  onClick={onToggleCourt}
                  className={`text-xs px-1 py-0.5 rounded ${isOnCourt ? 'bg-orange-600' : 'bg-gray-700 hover:bg-orange-700'}`}
                >
                  {isOnCourt ? 'üèì' : 'Send'}
                </button>
              )}
            </div>
          </div>
          <div className={`flex items-start gap-1 ${t1Won ? 'text-green-400 font-bold' : 'text-gray-300'}`}>
            <div className="flex-1 min-w-0">
              {t1 ? t1.name.split(' / ').map((p, i) => (
                <div key={i} className="text-xs leading-tight truncate">{p}</div>
              )) : <div className="text-xs">TBD</div>}
            </div>
            {isBo3Input ? (
              <div className="flex gap-1 flex-shrink-0">
                {Array.from({ length: numBo3Games }, (_, gi) => {
                  const g = (score.games || [])[gi] || { s1: '', s2: '' };
                  return <input key={gi} type="number" className="w-8 bg-gray-700 text-center rounded text-sm" value={g.s1 || ''} onChange={(e) => onBo3ScoreChange(gi, 's1', e.target.value)} />;
                })}
              </div>
            ) : hasBo3Games ? (
              <div className="flex gap-1 flex-shrink-0">
                {score.games.map((g, i) => (
                  <span key={i} className="w-7 bg-gray-700 text-center rounded text-sm">{g.s1}</span>
                ))}
              </div>
            ) : readOnly ? (
              <span className="w-10 text-center text-sm font-mono flex-shrink-0">{score.s1 || '-'}</span>
            ) : isReady && !override && (
              <input
                type="number"
                className="w-10 bg-gray-700 text-center rounded text-sm flex-shrink-0"
                value={score.s1 || ''}
                onChange={(e) => onScoreChange('s1', e.target.value)}
              />
            )}
            {showOverride && isReady && !override && !isBo3Input && !hasBo3Games && !readOnly && (
              <button className="text-xs bg-gray-700 px-1 rounded hover:bg-green-700 flex-shrink-0" onClick={() => onOverride(t1)}>W</button>
            )}
          </div>
          <div className={`flex items-start gap-1 mt-1 pt-1 border-t border-gray-700 ${t2Won ? 'text-green-400 font-bold' : 'text-gray-300'}`}>
            <div className="flex-1 min-w-0">
              {t2 ? t2.name.split(' / ').map((p, i) => (
                <div key={i} className="text-xs leading-tight truncate">{p}</div>
              )) : <div className="text-xs">TBD</div>}
            </div>
            {isBo3Input ? (
              <div className="flex gap-1 flex-shrink-0">
                {Array.from({ length: numBo3Games }, (_, gi) => {
                  const g = (score.games || [])[gi] || { s1: '', s2: '' };
                  return <input key={gi} type="number" className="w-8 bg-gray-700 text-center rounded text-sm" value={g.s2 || ''} onChange={(e) => onBo3ScoreChange(gi, 's2', e.target.value)} />;
                })}
              </div>
            ) : hasBo3Games ? (
              <div className="flex gap-1 flex-shrink-0">
                {score.games.map((g, i) => (
                  <span key={i} className="w-7 bg-gray-700 text-center rounded text-sm">{g.s2}</span>
                ))}
              </div>
            ) : readOnly ? (
              <span className="w-10 text-center text-sm font-mono flex-shrink-0">{score.s2 || '-'}</span>
            ) : isReady && !override && (
              <input
                type="number"
                className="w-10 bg-gray-700 text-center rounded text-sm flex-shrink-0"
                value={score.s2 || ''}
                onChange={(e) => onScoreChange('s2', e.target.value)}
              />
            )}
            {showOverride && isReady && !override && !isBo3Input && !hasBo3Games && !readOnly && (
              <button className="text-xs bg-gray-700 px-1 rounded hover:bg-green-700 flex-shrink-0" onClick={() => onOverride(t2)}>W</button>
            )}
          </div>
        </div>
      );
    });

    const TeamInput = memo(({ index, color, team, dupr, onChange, onDragStart, onDragOver, onDrop, isDragging, isDragOver }) => {
      return (
        <div
          draggable
          onDragStart={(e) => onDragStart(e, index)}
          onDragOver={(e) => onDragOver(e, index)}
          onDrop={(e) => onDrop(e, index)}
          onDragEnd={(e) => e.target.style.opacity = 1}
          className={`flex items-center gap-2 mb-2 bg-gray-800 p-2 rounded cursor-move border-2 transition-all ${
            isDragOver ? 'border-yellow-400 bg-gray-700' : 'border-transparent'
          } ${isDragging ? 'opacity-50' : ''}`}
        >
          <div className="flex flex-col items-center gap-1">
            <span className={`${color} w-5 font-bold text-sm text-center`}>{index + 1}</span>
            <span className="text-gray-500 text-xs">‚ò∞</span>
          </div>
          <div className="flex-1 flex flex-col gap-1">
            <div className="flex gap-1 items-center">
              <button
                onClick={(e) => { e.stopPropagation(); onChange('p1Paid', !team.p1Paid); }}
                onDragStart={(e) => e.stopPropagation()}
                draggable={false}
                className={`w-6 h-6 rounded text-xs font-bold flex-shrink-0 ${team.p1Paid ? 'bg-green-600 text-white' : 'bg-gray-700 text-gray-500 border border-gray-600'}`}
                title={team.p1Paid ? 'Paid' : 'Not paid'}
              >$</button>
              <input
                className="flex-1 bg-gray-700 border border-gray-600 rounded px-2 py-1 text-sm"
                placeholder="Player 1"
                value={team.p1Name}
                onChange={(e) => onChange('p1Name', e.target.value)}
                onDragStart={(e) => e.stopPropagation()}
                draggable={false}
              />
              <input
                className="w-12 bg-gray-700 border border-gray-600 rounded px-1 py-1 text-xs text-center"
                placeholder="4.5"
                type="number"
                step="0.01"
                value={team.p1Dupr}
                onChange={(e) => onChange('p1Dupr', e.target.value)}
                onDragStart={(e) => e.stopPropagation()}
                draggable={false}
              />
            </div>
            <div className="flex gap-1 items-center">
              <button
                onClick={(e) => { e.stopPropagation(); onChange('p2Paid', !team.p2Paid); }}
                onDragStart={(e) => e.stopPropagation()}
                draggable={false}
                className={`w-6 h-6 rounded text-xs font-bold flex-shrink-0 ${team.p2Paid ? 'bg-green-600 text-white' : 'bg-gray-700 text-gray-500 border border-gray-600'}`}
                title={team.p2Paid ? 'Paid' : 'Not paid'}
              >$</button>
              <input
                className="flex-1 bg-gray-700 border border-gray-600 rounded px-2 py-1 text-sm"
                placeholder="Player 2"
                value={team.p2Name}
                onChange={(e) => onChange('p2Name', e.target.value)}
                onDragStart={(e) => e.stopPropagation()}
                draggable={false}
              />
              <input
                className="w-12 bg-gray-700 border border-gray-600 rounded px-1 py-1 text-xs text-center"
                placeholder="4.5"
                type="number"
                step="0.01"
                value={team.p2Dupr}
                onChange={(e) => onChange('p2Dupr', e.target.value)}
                onDragStart={(e) => e.stopPropagation()}
                draggable={false}
              />
            </div>
          </div>
          <span className={`w-12 text-right text-sm font-mono font-bold ${dupr ? 'text-green-400' : 'text-gray-600'}`}>
            {dupr || '‚Äî'}
          </span>
        </div>
      );
    });

    const CourtStatus = memo(({ onCourtMatches, nextUpMatches, onToggleCourt }) => (
      <div className="mb-4 grid md:grid-cols-2 gap-2">
        <div className="bg-orange-900/30 border border-orange-500 rounded p-2">
          <div className="text-orange-400 text-xs font-semibold mb-1">üèì On Court ({onCourtMatches.length})</div>
          {onCourtMatches.length === 0 ? (
            <div className="text-gray-500 text-xs">No matches on court</div>
          ) : (
            <div className="space-y-1">
              {onCourtMatches.map(m => (
                <div key={m.id} className="text-xs text-orange-300">
                  {m.round || `Ct${m.court}`}: {m.t1?.name?.split('/')[0]} vs {m.t2?.name?.split('/')[0]}
                </div>
              ))}
            </div>
          )}
        </div>
        <div className="bg-gray-800 border border-gray-600 rounded p-2">
          <div className="text-gray-400 text-xs font-semibold mb-1">‚è≥ Next Up ({nextUpMatches.length})</div>
          {nextUpMatches.length === 0 ? (
            <div className="text-gray-500 text-xs">All done!</div>
          ) : (
            <div className="space-y-1">
              {nextUpMatches.slice(0, 4).map(m => (
                <div key={m.id} className="text-xs text-gray-300 flex justify-between">
                  <span>{m.round || `Ct${m.court}`}: {m.t1?.name?.split('/')[0]} vs {m.t2?.name?.split('/')[0]}</span>
                  <button onClick={() => onToggleCourt(m.id)} className="text-orange-400 hover:text-orange-300">Send‚Üí</button>
                </div>
              ))}
            </div>
          )}
        </div>
      </div>
    ));

    function App() {
      const [phase, setPhase] = useState('import');
      const [importText, setImportText] = useState(`Oscar Serra / Sanil Jagtiani
Jack Hared / Preston Gordon
Matvey Radionov / Matt Meadows
Lukas Choi / William Hayes
Jordan Denish / Alex Tong
Conor Landrigan / Geoff Watson
Cody Sadreameli / Dan Wach
Jeff Comer / Kenoa Tio
Matthew Matro / Zach Bowe
Bruno Casino Remondo / Drew Von Bargen
Austin Gow / Peter Weaver
Austin Keefer / Mason McCabe
Alex Boory / Ronald Marchese
Shashank Kamdar / Zachary Lessner
Kevin Herod / Jameson Mays
Matthew Chen / Johny Mario`);
      const [teamCount, setTeamCount] = useState(16);
      const [rrGames, setRrGames] = useState(3); // 2 or 3 RR games
      const [rrPointTarget, setRrPointTarget] = useState(11); // Games to 11 or 15
      const [winnersCount, setWinnersCount] = useState(8); // How many teams go to winners bracket
      const [teams, setTeams] = useState(Array.from({ length: 16 }, () => ({ p1Name: '', p1Dupr: '', p2Name: '', p2Dupr: '' })));
      const [seedingScores, setSeedingScores] = useState({});
      const [bracketScores, setBracketScores] = useState({});
      const [bracketOverrides, setBracketOverrides] = useState({});
      const [matchupsGenerated, setMatchupsGenerated] = useState(false);
      const [game1Matchups, setGame1Matchups] = useState([]);
      const [game2Matchups, setGame2Matchups] = useState([]);
      const [game3Matchups, setGame3Matchups] = useState([]);
      const [pools, setPools] = useState({});
      const [bracketSwaps, setBracketSwaps] = useState([]);
      const [onCourt, setOnCourt] = useState({});
      const [showOverride, setShowOverride] = useState(false);
      const [bracketSeedOverride, setBracketSeedOverride] = useState(null);
      const [selectedSwapTeam, setSelectedSwapTeam] = useState(null);
      const [standingsOverride, setStandingsOverride] = useState(null); // Array of seed numbers for manual reorder
      const [standingsDragIndex, setStandingsDragIndex] = useState(null);
      const [standingsDragOverIndex, setStandingsDragOverIndex] = useState(null);
      const [dragIndex, setDragIndex] = useState(null);
      const [dragOverIndex, setDragOverIndex] = useState(null);
      const [spectatorMode, setSpectatorMode] = useState(false);
      const [linkCopied, setLinkCopied] = useState(false);

      // Default winners count based on team count
      const defaultWinnersCount = { 12: 12, 13: 8, 14: 8, 15: 8, 16: 8 };

      // Load shared state from URL (handles both old and slim formats)
      const loadSharedState = (d) => {
        // Support both old keys (teamCount) and slim keys (tc)
        const v = (old, slim) => d[old] || d[slim];
        if (v('teamCount', 'tc')) setTeamCount(v('teamCount', 'tc'));
        if (v('rrGames', 'rg')) setRrGames(v('rrGames', 'rg'));
        if (v('rrPointTarget', 'rp')) setRrPointTarget(v('rrPointTarget', 'rp'));
        if (v('winnersCount', 'wc')) setWinnersCount(v('winnersCount', 'wc'));
        if (v('teams', 't')) setTeams(v('teams', 't'));
        if (v('seedingScores', 'ss')) setSeedingScores(v('seedingScores', 'ss'));
        if (v('bracketOverrides', 'bo')) setBracketOverrides(v('bracketOverrides', 'bo'));
        if (v('game1Matchups', 'g1')) setGame1Matchups(v('game1Matchups', 'g1'));
        if (v('game2Matchups', 'g2')) setGame2Matchups(v('game2Matchups', 'g2'));
        if (v('game3Matchups', 'g3')) setGame3Matchups(v('game3Matchups', 'g3'));
        if (v('pools', 'p')) setPools(v('pools', 'p'));
        if (v('matchupsGenerated', 'mg')) setMatchupsGenerated(v('matchupsGenerated', 'mg'));
        if (v('onCourt', 'oc')) setOnCourt(v('onCourt', 'oc'));
        if (v('bracketSeedOverride', 'bso')) setBracketSeedOverride(v('bracketSeedOverride', 'bso'));
        // Restore bracket scores: expand slim format back to full team objects
        if (d.bracketScores) {
          setBracketScores(d.bracketScores);
        } else if (d.bs) {
          const teams = v('teams', 't') || [];
          const getTeam = (seed) => {
            if (!seed) return null;
            const idx = seed - 1;
            const t = teams[idx];
            return t ? { seed, name: `${t.p1Name} / ${t.p2Name}` } : null;
          };
          const full = {};
          Object.entries(d.bs).forEach(([id, s]) => {
            if (s.g) {
              full[id] = { t1: getTeam(s.a), t2: getTeam(s.b), games: s.g };
            } else {
              full[id] = { t1: getTeam(s.a), t2: getTeam(s.b), s1: s.s1, s2: s.s2 };
            }
          });
          setBracketScores(full);
        }
        setSpectatorMode(true);
        setPhase(v('phase', 'ph') || 'bracket');
      };

      React.useEffect(() => {
        const params = new URLSearchParams(window.location.search);
        const sharedState = params.get('s');
        if (sharedState) {
          try {
            let decoded;
            try {
              let base64 = sharedState.replace(/-/g, '+').replace(/_/g, '/');
              while (base64.length % 4) base64 += '=';
              const binary = atob(base64);
              const bytes = new Uint8Array(binary.length);
              for (let i = 0; i < binary.length; i++) bytes[i] = binary.charCodeAt(i);
              const decompressed = pako.inflate(bytes, { to: 'string' });
              decoded = JSON.parse(decompressed);
            } catch (compressError) {
              decoded = JSON.parse(atob(sharedState));
            }
            loadSharedState(decoded);
          } catch (e) {
            console.error('Failed to load shared state', e);
          }
        }
      }, []);

      const shareLink = useCallback(() => {
        // Build slim state for sharing (strip redundant team objects from bracket scores)
        const state = {
          tc: teamCount, rg: rrGames, rp: rrPointTarget, wc: winnersCount,
          t: teams, ss: seedingScores, bo: bracketOverrides,
          g1: game1Matchups, g2: game2Matchups, g3: game3Matchups,
          p: pools, mg: matchupsGenerated, oc: onCourt, bso: bracketSeedOverride, ph: phase
        };
        // Slim bracket scores: store only seeds + scores (no full team objects)
        if (Object.keys(bracketScores).length > 0) {
          const slim = {};
          Object.entries(bracketScores).forEach(([id, s]) => {
            if (s.games) {
              slim[id] = { a: s.t1?.seed, b: s.t2?.seed, g: s.games };
            } else {
              slim[id] = { a: s.t1?.seed, b: s.t2?.seed, s1: s.s1, s2: s.s2 };
            }
          });
          state.bs = slim;
        }
        const jsonStr = JSON.stringify(state);
        const compressed = pako.deflate(jsonStr);
        // Chunked base64 to avoid call stack overflow
        let binary = '';
        for (let i = 0; i < compressed.length; i++) binary += String.fromCharCode(compressed[i]);
        const base64 = btoa(binary);
        const urlSafe = base64.replace(/\+/g, '-').replace(/\//g, '_').replace(/=+$/, '');
        const url = `${window.location.origin}${window.location.pathname}?s=${urlSafe}`;
        navigator.clipboard.writeText(url).then(() => {
          setLinkCopied(true);
          setTimeout(() => setLinkCopied(false), 2000);
        });
      }, [teamCount, rrGames, rrPointTarget, winnersCount, teams, seedingScores, bracketScores, bracketOverrides, game1Matchups, game2Matchups, game3Matchups, pools, matchupsGenerated, onCourt, bracketSeedOverride, phase]);

      const handleDragStart = useCallback((e, index) => {
        setDragIndex(index);
        e.dataTransfer.effectAllowed = 'move';
      }, []);

      const handleDragOver = useCallback((e, index) => {
        e.preventDefault();
        setDragOverIndex(index);
      }, []);

      const handleDrop = useCallback((e, dropIndex) => {
        e.preventDefault();
        if (dragIndex === null || dragIndex === dropIndex) {
          setDragIndex(null);
          setDragOverIndex(null);
          return;
        }
        setTeams(prev => {
          const newTeams = [...prev];
          const [draggedTeam] = newTeams.splice(dragIndex, 1);
          newTeams.splice(dropIndex, 0, draggedTeam);
          return newTeams;
        });
        setDragIndex(null);
        setDragOverIndex(null);
      }, [dragIndex]);

      const handleStandingsDragStart = useCallback((e, index) => {
        setStandingsDragIndex(index);
        e.dataTransfer.effectAllowed = 'move';
      }, []);

      const handleStandingsDragOver = useCallback((e, index) => {
        e.preventDefault();
        setStandingsDragOverIndex(index);
      }, []);

      const handleStandingsDrop = useCallback((e, dropIndex) => {
        e.preventDefault();
        if (standingsDragIndex === null || standingsDragIndex === dropIndex) {
          setStandingsDragIndex(null);
          setStandingsDragOverIndex(null);
          return;
        }
        const current = standingsOverride || standings.map(t => t.seed);
        const newOrder = [...current];
        const [dragged] = newOrder.splice(standingsDragIndex, 1);
        newOrder.splice(dropIndex, 0, dragged);
        setStandingsOverride(newOrder);
        setBracketSeedOverride(null); // Clear bracket override when standings change
        setStandingsDragIndex(null);
        setStandingsDragOverIndex(null);
      }, [standingsDragIndex, standingsOverride, standings]);

      const getTeamDupr = useCallback((team) => {
        const p1 = parseFloat(team.p1Dupr) || 0;
        const p2 = parseFloat(team.p2Dupr) || 0;
        if (!team.p1Dupr && !team.p2Dupr) return null;
        return (p1 + p2).toFixed(2);
      }, []);

      const getTeamName = useCallback((team) => {
        if (!team.p1Name && !team.p2Name) return '';
        if (!team.p2Name) return team.p1Name;
        if (!team.p1Name) return team.p2Name;
        return `${team.p1Name} / ${team.p2Name}`;
      }, []);

      const teamsValid = teams.every(t => t.p1Name && t.p2Name);

      const parseImportText = useCallback(() => {
        const lines = importText.split('\n').filter(l => l.trim());
        const parsed = lines.map(line => {
          const cleaned = line.replace(/^[\s\*\-\d\.\)\:]+/, '').trim();
          const parts = cleaned.split(/\s*\/\s*/);
          if (parts.length >= 2) {
            return { p1Name: parts[0].trim(), p1Dupr: '', p2Name: parts[1].trim(), p2Dupr: '' };
          }
          return null;
        }).filter(Boolean);

        if (parsed.length !== teamCount) {
          alert(`Expected ${teamCount} teams, found ${parsed.length}.`);
        } else {
          setWinnersCount(defaultWinnersCount[teamCount] || 8);
          setTeams(parsed);
          setPhase('setup');
        }
      }, [importText, teamCount]);

      const generateRandomMatchups = useCallback(() => {
        const shuffle = (arr) => {
          const a = [...arr];
          for (let i = a.length - 1; i > 0; i--) {
            const j = Math.floor(Math.random() * (i + 1));
            [a[i], a[j]] = [a[j], a[i]];
          }
          return a;
        };

        // 2 RR games: seed-balanced random for all team counts
        if (rrGames === 2) {
          const allTeams = Array.from({ length: teamCount }, (_, i) => i);

          // Round 1: pair nearby seeds (0v1, 2v3, 4v5, etc.)
          const g1 = [];
          for (let i = 0; i < teamCount - 1; i += 2) {
            g1.push({ t1: allTeams[i], t2: allTeams[i + 1] });
          }

          // Round 2: shift pairing (0v2, 1v3, 4v6, 5v7, etc.)
          const g2 = [];
          for (let i = 0; i < teamCount - 1; i += 2) {
            const t1 = allTeams[i];
            const t2 = allTeams[Math.min(i + 2, teamCount - 1)];
            // Avoid same matchup as round 1
            if (t2 === allTeams[i + 1]) {
              g2.push({ t1, t2: allTeams[Math.min(i + 3, teamCount - 1)] });
            } else {
              g2.push({ t1, t2 });
            }
          }
          // Better approach: interleave for round 2 (0v2, 1v3, 4v6, 5v7...)
          const g2Better = [];
          const used = new Set();
          for (let i = 0; i < teamCount; i++) {
            if (used.has(i)) continue;
            const opponent = i + 2 < teamCount && !used.has(i + 2) ? i + 2 :
                            (i + 1 < teamCount && !used.has(i + 1) ? i + 1 : null);
            if (opponent !== null) {
              g2Better.push({ t1: i, t2: opponent });
              used.add(i);
              used.add(opponent);
            }
          }

          setGame1Matchups(shuffle(g1));
          setGame2Matchups(shuffle(g2Better.length >= g1.length ? g2Better : g2));
          setGame3Matchups([]);
          setPools({});
        }
        // 3 RR games: pools for 12/16, random for 13-15
        else if (teamCount === 12 || teamCount === 16) {
          const numPools = teamCount === 12 ? 3 : 4;

          // Snake draft: 1,2,3,4 then 8,7,6,5 then 9,10,11,12...
          const poolAssignments = {};
          const poolTeams = Array.from({ length: numPools }, () => []);

          for (let i = 0; i < teamCount; i++) {
            const row = Math.floor(i / numPools);
            let poolIdx = i % numPools;
            if (row % 2 === 1) poolIdx = numPools - 1 - poolIdx; // Snake
            poolTeams[poolIdx].push(i);
            poolAssignments[i] = poolIdx;
          }

          setPools(poolAssignments);

          // Within each pool: Game 1: 1v3, 2v4; Game 2: 1v2, 3v4; Game 3: 1v4, 2v3
          const g1 = [], g2 = [], g3 = [];
          poolTeams.forEach(pool => {
            g1.push({ t1: pool[0], t2: pool[2] }, { t1: pool[1], t2: pool[3] });
            g2.push({ t1: pool[0], t2: pool[1] }, { t1: pool[2], t2: pool[3] });
            g3.push({ t1: pool[0], t2: pool[3] }, { t1: pool[1], t2: pool[2] });
          });

          // Don't shuffle pool matchups - keep consistent order (1v3, 2v4 per pool)
          setGame1Matchups(g1);
          setGame2Matchups(g2);
          setGame3Matchups(g3);
        } else {
          // 13, 14, 15 teams: 3 random RR games
          const allTeams = Array.from({ length: teamCount }, (_, i) => i);
          const opponents = {};
          allTeams.forEach(t => opponents[t] = []);

          const g1 = [], g2 = [], g3 = [];

          for (let round = 0; round < 3; round++) {
            const available = [...allTeams];
            const roundMatches = [];

            while (available.length >= 2) {
              const t1 = available.shift();
              let t2Idx = available.findIndex(t => !opponents[t1].includes(t));
              if (t2Idx === -1) t2Idx = 0;
              const t2 = available.splice(t2Idx, 1)[0];

              opponents[t1].push(t2);
              opponents[t2].push(t1);
              roundMatches.push({ t1, t2 });
            }

            if (round === 0) setGame1Matchups(shuffle(roundMatches));
            else if (round === 1) setGame2Matchups(shuffle(roundMatches));
            else setGame3Matchups(shuffle(roundMatches));
          }

          setPools({});
        }

        setMatchupsGenerated(true);
        setSeedingScores({});
      }, [teamCount, rrGames]);

      const teamData = useMemo(() => {
        return teams.map((t, i) => ({
          seed: i + 1,
          name: getTeamName(t),
          dupr: getTeamDupr(t)
        }));
      }, [teams, getTeamName, getTeamDupr]);

      const seedingMatches = useMemo(() => {
        const t = teamData;
        if (matchupsGenerated && game1Matchups.length && game2Matchups.length) {
          const result = {
            game1: game1Matchups.map((m, i) => ({
              id: `g1m${i}`,
              t1: t[m.t1],
              t2: t[m.t2],
              court: i + 1
            })),
            game2: game2Matchups.map((m, i) => ({
              id: `g2m${i}`,
              t1: t[m.t1],
              t2: t[m.t2],
              court: i + 1
            })),
            game3: game3Matchups.map((m, i) => ({
              id: `g3m${i}`,
              t1: t[m.t1],
              t2: t[m.t2],
              court: i + 1
            }))
          };
          return result;
        }
        return { game1: [], game2: [], game3: [] };
      }, [teamData, matchupsGenerated, game1Matchups, game2Matchups, game3Matchups]);

      const standings = useMemo(() => {
        const stats = {};
        teamData.forEach(t => {
          stats[t.seed] = { ...t, wins: 0, losses: 0, pf: 0, pa: 0, h2h: {}, pool: pools[t.seed - 1] };
        });

        [...seedingMatches.game1, ...seedingMatches.game2, ...seedingMatches.game3].forEach(m => {
          const score = seedingScores[m.id];
          if (score && score.s1 !== '' && score.s2 !== '' && score.s1 !== undefined && score.s2 !== undefined) {
            const s1 = parseInt(score.s1);
            const s2 = parseInt(score.s2);
            if (!isNaN(s1) && !isNaN(s2)) {
              stats[m.t1.seed].pf += s1;
              stats[m.t1.seed].pa += s2;
              stats[m.t2.seed].pf += s2;
              stats[m.t2.seed].pa += s1;

              if (s1 > s2) {
                stats[m.t1.seed].wins++;
                stats[m.t2.seed].losses++;
                stats[m.t1.seed].h2h[m.t2.seed] = { result: 1, pf: s1, pa: s2 };
                stats[m.t2.seed].h2h[m.t1.seed] = { result: -1, pf: s2, pa: s1 };
              } else if (s2 > s1) {
                stats[m.t2.seed].wins++;
                stats[m.t1.seed].losses++;
                stats[m.t2.seed].h2h[m.t1.seed] = { result: 1, pf: s2, pa: s1 };
                stats[m.t1.seed].h2h[m.t2.seed] = { result: -1, pf: s1, pa: s2 };
              }
            }
          }
        });

        // 3-way tiebreaker: group h2h within tied teams, then group PD, then overall PD
        // Only uses H2H when ALL teams in the group played each other (same pool)
        const resolveTiedGroup = (group) => {
          if (group.length <= 1) return group;

          // Check if all teams in the group played each other
          let allPlayedEachOther = true;
          for (let i = 0; i < group.length && allPlayedEachOther; i++) {
            for (let j = i + 1; j < group.length && allPlayedEachOther; j++) {
              if (!group[i].h2h[group[j].seed]) {
                allPlayedEachOther = false;
              }
            }
          }

          if (!allPlayedEachOther) {
            // Cross-pool tie: can't use H2H, sort by overall PD only
            return [...group].sort((a, b) => (b.pf - b.pa) - (a.pf - a.pa));
          }

          // All played each other: use group H2H wins, then group PD, then overall PD
          const withG = group.map(t => {
            let gW = 0, gPf = 0, gPa = 0;
            group.forEach(o => {
              if (t.seed === o.seed) return;
              const h = t.h2h[o.seed];
              if (h) {
                if (h.result === 1) gW++;
                gPf += h.pf || 0;
                gPa += h.pa || 0;
              }
            });
            return { ...t, gW, gPd: gPf - gPa };
          });
          withG.sort((a, b) => {
            if (b.gW !== a.gW) return b.gW - a.gW;
            if (b.gPd !== a.gPd) return b.gPd - a.gPd;
            return (b.pf - b.pa) - (a.pf - a.pa);
          });
          const result = [];
          let si = 0;
          while (si < withG.length) {
            let sj = si + 1;
            while (sj < withG.length && withG[sj].gW === withG[si].gW && withG[sj].gPd === withG[si].gPd) sj++;
            const sub = withG.slice(si, sj);
            if (sub.length > 1 && sub.length < group.length) {
              result.push(...resolveTiedGroup(sub));
            } else {
              result.push(...sub);
            }
            si = sj;
          }
          return result;
        };
        const allTeams = Object.values(stats).sort((a, b) => b.wins - a.wins);
        const resolved = [];
        let gi = 0;
        while (gi < allTeams.length) {
          let gj = gi + 1;
          while (gj < allTeams.length && allTeams[gj].wins === allTeams[gi].wins) gj++;
          resolved.push(...resolveTiedGroup(allTeams.slice(gi, gj)));
          gi = gj;
        }
        return resolved;
      }, [teamData, seedingScores, seedingMatches]);

      // Apply manual standings reorder if set, keeping fresh stats from computed standings
      const displayStandings = useMemo(() => {
        if (!standingsOverride) return standings;
        const ordered = standingsOverride
          .map(seed => standings.find(t => t.seed === seed))
          .filter(Boolean);
        // Add any teams not in the override
        standings.forEach(t => {
          if (!ordered.find(o => o.seed === t.seed)) ordered.push(t);
        });
        return ordered;
      }, [standingsOverride, standings]);

      const bracketTeams = useMemo(() => {
        if (bracketSeedOverride) {
          return { winners: bracketSeedOverride.winners, losers: bracketSeedOverride.losers, swaps: [] };
        }
        if (displayStandings.length < teamCount) return { winners: [], losers: [], swaps: [] };

        // Split into winners and losers based on configured winnersCount
        const losersCount = teamCount - winnersCount;
        let winners = displayStandings.slice(0, winnersCount);
        let losers = displayStandings.slice(winnersCount);

        const swaps = [];

        // Apply no-repeat constraint: no same-pool matchups in round 1
        // Standard matchups by seed: 1v8, 4v5, 2v7, 3v6 (for 8 teams)
        const applyNoRepeat = (teams, bracketName) => {
          if (teams.length < 2) return teams;
          const result = [...teams];

          // Get matchups based on team count
          const getMatchups = (n) => {
            if (n <= 4) return [[0, n-1], [1, n-2]].filter(m => m[1] >= 0 && m[0] < m[1]);
            if (n <= 6) return [[0, n-1], [1, n-2], [2, n-3]].filter(m => m[1] >= 0 && m[0] < m[1]);
            if (n <= 8) return [[0, 7], [3, 4], [1, 6], [2, 5]].filter(m => m[1] < n);
            return [[0, 7], [3, 4], [1, 6], [2, 5]];
          };

          const matchups = getMatchups(result.length);

          // Check each matchup for same-pool conflict
          for (const [i, j] of matchups) {
            if (i >= result.length || j >= result.length) continue;
            const t1 = result[i];
            const t2 = result[j];

            // Check if same pool (only if pools are assigned)
            if (t1.pool !== undefined && t2.pool !== undefined && t1.pool === t2.pool) {
              // Find someone to swap with (not seed 1, and not from same pool as opponent)
              for (let k = j + 1; k < result.length; k++) {
                if (result[k].pool !== t1.pool) {
                  // Also check that swapping doesn't create a new conflict
                  const otherMatchup = matchups.find(m => m.includes(k));
                  if (otherMatchup) {
                    const otherIdx = otherMatchup[0] === k ? otherMatchup[1] : otherMatchup[0];
                    if (otherIdx < result.length && result[otherIdx].pool === t2.pool) continue; // Would create new conflict
                  }

                  swaps.push(`${bracketName}: Swapped seed ${j + 1} (${t2.name}) with seed ${k + 1} (${result[k].name}) to avoid pool rematch`);
                  [result[j], result[k]] = [result[k], result[j]];
                  break;
                }
              }
            }
          }
          return result;
        };

        winners = applyNoRepeat(winners, 'Winners');
        losers = applyNoRepeat(losers, 'Losers');

        setBracketSwaps(swaps);

        return { winners, losers, swaps };
      }, [displayStandings, teamCount, winnersCount, bracketSeedOverride]);

      const generateFakeSeedingScores = useCallback(() => {
        const fakeScores = {};
        [...seedingMatches.game1, ...seedingMatches.game2, ...seedingMatches.game3].forEach(m => {
          const seedDiff = m.t2.seed - m.t1.seed; // positive = t1 is better seed
          const t1WinProb = 0.5 + (seedDiff * 0.03); // 3% advantage per seed difference
          const t1Wins = Math.random() < t1WinProb;
          const winScore = 11;
          const loseScore = Math.floor(Math.random() * 8) + 2; // 2-9
          fakeScores[m.id] = {
            s1: t1Wins ? winScore : loseScore,
            s2: t1Wins ? loseScore : winScore
          };
        });
        setSeedingScores(fakeScores);
      }, [seedingMatches]);

      const generateFakeBracketScores = useCallback(() => {
        const fakeScores = {};

        // We need to simulate in order since later matches depend on earlier results
        const getWinner = (id) => {
          const s = fakeScores[id];
          if (!s) return null;
          // Handle Bo3 with games array
          if (s.games) {
            let t1Wins = 0, t2Wins = 0;
            s.games.forEach(g => { if (g.s1 > g.s2) t1Wins++; else t2Wins++; });
            return t1Wins > t2Wins ? s.t1 : s.t2;
          }
          return parseInt(s.s1) > parseInt(s.s2) ? s.t1 : s.t2;
        };
        const getLoser = (id) => {
          const s = fakeScores[id];
          if (!s) return null;
          // Handle Bo3 with games array
          if (s.games) {
            let t1Wins = 0, t2Wins = 0;
            s.games.forEach(g => { if (g.s1 > g.s2) t1Wins++; else t2Wins++; });
            return t1Wins > t2Wins ? s.t2 : s.t1;
          }
          return parseInt(s.s1) > parseInt(s.s2) ? s.t2 : s.t1;
        };

        const w = bracketTeams.winners;
        const l = bracketTeams.losers;
        if (w.length < 8) return;

        const simulateMatch = (t1, t2) => {
          if (!t1 || !t2) return null;
          const seedDiff = t2.seed - t1.seed;
          const t1WinProb = 0.5 + (seedDiff * 0.025);
          const t1Wins = Math.random() < t1WinProb;
          const winScore = 15;
          const loseScore = Math.floor(Math.random() * 10) + 4; // 4-13
          return { t1, t2, s1: t1Wins ? winScore : loseScore, s2: t1Wins ? loseScore : winScore };
        };

        // Bo3 matches store individual game scores to 11
        const simulateBo3Match = (t1, t2) => {
          if (!t1 || !t2) return null;
          const seedDiff = t2.seed - t1.seed;
          const t1WinProb = 0.5 + (seedDiff * 0.025);

          const games = [];
          let t1Wins = 0, t2Wins = 0;

          while (t1Wins < 2 && t2Wins < 2) {
            const t1WinsGame = Math.random() < t1WinProb;
            const winScore = 11;
            const loseScore = Math.floor(Math.random() * 8) + 2; // 2-9
            games.push({
              s1: t1WinsGame ? winScore : loseScore,
              s2: t1WinsGame ? loseScore : winScore
            });
            if (t1WinsGame) t1Wins++; else t2Wins++;
          }

          return { t1, t2, games };
        };

        // Winners QF
        fakeScores.wqf1 = simulateMatch(w[0], w[7]);
        fakeScores.wqf2 = simulateMatch(w[3], w[4]);
        fakeScores.wqf3 = simulateMatch(w[1], w[6]);
        fakeScores.wqf4 = simulateMatch(w[2], w[5]);

        // Losers R1
        fakeScores.lr1m1 = simulateMatch(l[0], l[7]);
        fakeScores.lr1m2 = simulateMatch(l[3], l[4]);
        fakeScores.lr1m3 = simulateMatch(l[1], l[6]);
        fakeScores.lr1m4 = simulateMatch(l[2], l[5]);

        // Winners SF
        fakeScores.wsf1 = simulateMatch(getWinner('wqf1'), getWinner('wqf2'));
        fakeScores.wsf2 = simulateMatch(getWinner('wqf3'), getWinner('wqf4'));

        // Losers R2
        fakeScores.lr2m1 = simulateMatch(getWinner('lr1m1'), getLoser('wqf1'));
        fakeScores.lr2m2 = simulateMatch(getWinner('lr1m2'), getLoser('wqf2'));
        fakeScores.lr2m3 = simulateMatch(getWinner('lr1m3'), getLoser('wqf3'));
        fakeScores.lr2m4 = simulateMatch(getWinner('lr1m4'), getLoser('wqf4'));

        // Losers R3
        fakeScores.lr3m1 = simulateMatch(getWinner('lr2m1'), getWinner('lr2m2'));
        fakeScores.lr3m2 = simulateMatch(getWinner('lr2m3'), getWinner('lr2m4'));

        // Winners Final (Bo3)
        fakeScores.wf = simulateBo3Match(getWinner('wsf1'), getWinner('wsf2'));

        // Losers R4
        fakeScores.lr4m1 = simulateMatch(getWinner('lr3m1'), getLoser('wsf1'));
        fakeScores.lr4m2 = simulateMatch(getWinner('lr3m2'), getLoser('wsf2'));

        // Losers Semi
        fakeScores.lsf = simulateMatch(getWinner('lr4m1'), getWinner('lr4m2'));

        // Losers Final
        fakeScores.lf = simulateMatch(getWinner('lsf'), getLoser('wf'));

        // Grand Final (Bo3)
        fakeScores.gf = simulateBo3Match(getWinner('wf'), getWinner('lf'));

        setBracketScores(fakeScores);
      }, [bracketTeams]);

      const getBracketMatchTeam = useCallback((id) => {
        if (bracketOverrides[id] && bracketOverrides[id].winner) {
          return bracketOverrides[id].winner;
        }
        const score = bracketScores[id];
        if (!score) return null;

        // Handle Bo3 with games array
        if (score.games && score.games.length > 0) {
          let t1Wins = 0, t2Wins = 0;
          score.games.forEach(g => {
            const s1v = parseInt(g.s1), s2v = parseInt(g.s2);
            if (!isNaN(s1v) && !isNaN(s2v)) {
              if (s1v > s2v) t1Wins++;
              else if (s2v > s1v) t2Wins++;
            }
          });
          if (t1Wins >= 2) return score.t1;
          if (t2Wins >= 2) return score.t2;
          return null;
        }

        // Regular match
        if (score.s1 === '' || score.s2 === '' || score.s1 === undefined || score.s2 === undefined) return null;
        return parseInt(score.s1) > parseInt(score.s2) ? score.t1 : score.t2;
      }, [bracketScores, bracketOverrides]);

      const getBracketMatchLoser = useCallback((id) => {
        if (bracketOverrides[id] && bracketOverrides[id].loser) {
          return bracketOverrides[id].loser;
        }
        const score = bracketScores[id];
        if (!score) return null;

        // Handle Bo3 with games array
        if (score.games && score.games.length > 0) {
          let t1Wins = 0, t2Wins = 0;
          score.games.forEach(g => {
            const s1v = parseInt(g.s1), s2v = parseInt(g.s2);
            if (!isNaN(s1v) && !isNaN(s2v)) {
              if (s1v > s2v) t1Wins++;
              else if (s2v > s1v) t2Wins++;
            }
          });
          if (t1Wins >= 2) return score.t2;
          if (t2Wins >= 2) return score.t1;
          return null;
        }

        // Regular match
        if (score.s1 === '' || score.s2 === '' || score.s1 === undefined || score.s2 === undefined) return null;
        return parseInt(score.s1) > parseInt(score.s2) ? score.t2 : score.t1;
      }, [bracketScores, bracketOverrides]);

      const bracketMatches = useMemo(() => {
        const w = bracketTeams.winners || [];
        const l = bracketTeams.losers || [];
        if (w.length < 6 || teamCount < 12) return {}; // Need at least 6 winners for a meaningful bracket

        // For now, support 16-team bracket (8v8) fully
        // TODO: Add byes for 12-15 teams
        if (w.length < 8 || l.length < 8) return {};

        return {
          wqf1: { id: 'wqf1', t1: w[0], t2: w[7], round: 'W-QF', court: 1 },
          wqf2: { id: 'wqf2', t1: w[3], t2: w[4], round: 'W-QF', court: 2 },
          wqf3: { id: 'wqf3', t1: w[1], t2: w[6], round: 'W-QF', court: 3 },
          wqf4: { id: 'wqf4', t1: w[2], t2: w[5], round: 'W-QF', court: 4 },
          wsf1: { id: 'wsf1', t1: getBracketMatchTeam('wqf1'), t2: getBracketMatchTeam('wqf2'), round: 'W-SF' },
          wsf2: { id: 'wsf2', t1: getBracketMatchTeam('wqf3'), t2: getBracketMatchTeam('wqf4'), round: 'W-SF' },
          wf: { id: 'wf', t1: getBracketMatchTeam('wsf1'), t2: getBracketMatchTeam('wsf2'), round: 'W-Final', bo3: true },
          lr1m1: { id: 'lr1m1', t1: l[0], t2: l[7], round: 'L-R1', court: 5 },
          lr1m2: { id: 'lr1m2', t1: l[3], t2: l[4], round: 'L-R1', court: 6 },
          lr1m3: { id: 'lr1m3', t1: l[1], t2: l[6], round: 'L-R1', court: 7 },
          lr1m4: { id: 'lr1m4', t1: l[2], t2: l[5], round: 'L-R1', court: 8 },
          lr2m1: { id: 'lr2m1', t1: getBracketMatchTeam('lr1m1'), t2: getBracketMatchLoser('wqf1'), round: 'L-R2' },
          lr2m2: { id: 'lr2m2', t1: getBracketMatchTeam('lr1m2'), t2: getBracketMatchLoser('wqf2'), round: 'L-R2' },
          lr2m3: { id: 'lr2m3', t1: getBracketMatchTeam('lr1m3'), t2: getBracketMatchLoser('wqf3'), round: 'L-R2' },
          lr2m4: { id: 'lr2m4', t1: getBracketMatchTeam('lr1m4'), t2: getBracketMatchLoser('wqf4'), round: 'L-R2' },
          lr3m1: { id: 'lr3m1', t1: getBracketMatchTeam('lr2m1'), t2: getBracketMatchTeam('lr2m2'), round: 'L-R3' },
          lr3m2: { id: 'lr3m2', t1: getBracketMatchTeam('lr2m3'), t2: getBracketMatchTeam('lr2m4'), round: 'L-R3' },
          lr4m1: { id: 'lr4m1', t1: getBracketMatchTeam('lr3m1'), t2: getBracketMatchLoser('wsf1'), round: 'L-R4' },
          lr4m2: { id: 'lr4m2', t1: getBracketMatchTeam('lr3m2'), t2: getBracketMatchLoser('wsf2'), round: 'L-R4' },
          lsf: { id: 'lsf', t1: getBracketMatchTeam('lr4m1'), t2: getBracketMatchTeam('lr4m2'), round: 'L-Semi' },
          lf: { id: 'lf', t1: getBracketMatchTeam('lsf'), t2: getBracketMatchLoser('wf'), round: 'L-Final' },
          gf: { id: 'gf', t1: getBracketMatchTeam('wf'), t2: getBracketMatchTeam('lf'), round: 'Grand Final', bo3: true }
        };
      }, [bracketTeams, getBracketMatchTeam, getBracketMatchLoser]);

      const handleTeamChange = useCallback((index, field, value) => {
        setTeams(prev => prev.map((t, i) => i === index ? { ...t, [field]: value } : t));
      }, []);

      const handleSeedingScore = useCallback((id, field, value) => {
        setSeedingScores(prev => ({
          ...prev,
          [id]: { ...prev[id], [field]: value }
        }));
      }, []);

      const handleBracketScore = useCallback((matchId, t1, t2, field, value) => {
        setBracketScores(prev => ({
          ...prev,
          [matchId]: {
            t1,
            t2,
            s1: field === 's1' ? value : (prev[matchId]?.s1 || ''),
            s2: field === 's2' ? value : (prev[matchId]?.s2 || '')
          }
        }));
      }, []);

      const handleBo3Score = useCallback((matchId, t1, t2, gameIndex, field, value) => {
        setBracketScores(prev => {
          const existing = prev[matchId] || { t1, t2, games: [] };
          const games = [...(existing.games || [])];
          while (games.length <= gameIndex) games.push({ s1: '', s2: '' });
          games[gameIndex] = { ...games[gameIndex], [field]: value };
          return { ...prev, [matchId]: { t1, t2, games } };
        });
      }, []);

      const handleBracketOverride = useCallback((id, winner, loser) => {
        setBracketOverrides(prev => ({ ...prev, [id]: { winner, loser } }));
      }, []);

      const clearBracketOverride = useCallback((id) => {
        setBracketOverrides(prev => {
          const newOverrides = { ...prev };
          delete newOverrides[id];
          return newOverrides;
        });
      }, []);

      const handleSeedSwap = useCallback((side, pos) => {
        if (!selectedSwapTeam) {
          setSelectedSwapTeam({ side, pos });
          return;
        }
        if (selectedSwapTeam.side === side && selectedSwapTeam.pos === pos) {
          setSelectedSwapTeam(null);
          return;
        }
        const current = {
          winners: [...(bracketSeedOverride?.winners || bracketTeams.winners)],
          losers: [...(bracketSeedOverride?.losers || bracketTeams.losers)]
        };
        if (selectedSwapTeam.side === side) {
          const arr = current[side];
          [arr[selectedSwapTeam.pos], arr[pos]] = [arr[pos], arr[selectedSwapTeam.pos]];
        } else {
          const w = current.winners;
          const l = current.losers;
          if (selectedSwapTeam.side === 'winners') {
            [w[selectedSwapTeam.pos], l[pos]] = [l[pos], w[selectedSwapTeam.pos]];
          } else {
            [l[selectedSwapTeam.pos], w[pos]] = [w[pos], l[selectedSwapTeam.pos]];
          }
        }
        setBracketSeedOverride(current);
        setBracketScores({});
        setBracketOverrides({});
        setSelectedSwapTeam(null);
      }, [selectedSwapTeam, bracketSeedOverride, bracketTeams]);

      const toggleOnCourt = useCallback((id) => {
        setOnCourt(prev => ({ ...prev, [id]: !prev[id] }));
      }, []);

      const allSeedingComplete = useMemo(() => {
        const allMatches = [...seedingMatches.game1, ...seedingMatches.game2, ...seedingMatches.game3];
        if (!allMatches.length) return false;
        return allMatches.every(m => {
          const s = seedingScores[m.id];
          return s && s.s1 !== '' && s.s2 !== '' && s.s1 !== undefined && s.s2 !== undefined;
        });
      }, [seedingMatches, seedingScores]);

      const onCourtMatches = useMemo(() => {
        const matches = [];
        Object.keys(onCourt).forEach(id => {
          if (onCourt[id]) {
            const seedMatch = [...seedingMatches.game1, ...seedingMatches.game2, ...seedingMatches.game3].find(m => m.id === id);
            if (seedMatch) {
              matches.push({ ...seedMatch, type: 'seeding' });
              return;
            }
            if (bracketMatches[id]) {
              matches.push({ ...bracketMatches[id], type: 'bracket' });
            }
          }
        });
        return matches;
      }, [onCourt, seedingMatches, bracketMatches]);

      const nextUpMatches = useMemo(() => {
        const next = [];
        if (phase === 'roundrobin') {
          [...seedingMatches.game1, ...seedingMatches.game2].forEach(m => {
            const s = seedingScores[m.id];
            const complete = s && s.s1 !== '' && s.s2 !== '' && s.s1 !== undefined && s.s2 !== undefined;
            if (!complete && !onCourt[m.id]) {
              next.push({ ...m, type: 'seeding' });
            }
          });
        }
        if (phase === 'bracket') {
          const order = ['wqf1','wqf2','wqf3','wqf4','lr1m1','lr1m2','lr1m3','lr1m4','wsf1','wsf2','lr2m1','lr2m2','lr2m3','lr2m4','lr3m1','lr3m2','lr4m1','lr4m2','lsf','wf','lf','gf'];
          order.forEach(id => {
            const m = bracketMatches[id];
            const s = bracketScores[id];
            const o = bracketOverrides[id];
            let complete = o || (s && s.s1 !== '' && s.s2 !== '' && s.s1 !== undefined && s.s2 !== undefined);
            // Check Bo3 completion
            if (!complete && s && s.games && s.games.length > 0) {
              let t1w = 0, t2w = 0;
              s.games.forEach(g => { const a = parseInt(g.s1), b = parseInt(g.s2); if (!isNaN(a) && !isNaN(b)) { if (a > b) t1w++; else if (b > a) t2w++; } });
              complete = t1w >= 2 || t2w >= 2;
            }
            if (m && m.t1 && m.t2 && !complete && !onCourt[id]) {
              next.push({ ...m, type: 'bracket' });
            }
          });
        }
        return next;
      }, [phase, seedingMatches, seedingScores, bracketMatches, bracketScores, bracketOverrides, onCourt]);

      const saveProgress = useCallback(() => {
        const data = {
          teamCount,
          rrGames,
          rrPointTarget,
          winnersCount,
          teams,
          seedingScores,
          bracketScores,
          bracketOverrides,
          matchupsGenerated,
          game1Matchups,
          game2Matchups,
          game3Matchups,
          pools,
          onCourt,
          bracketSeedOverride
        };
        const blob = new Blob([JSON.stringify(data, null, 2)], { type: 'application/json' });
        const url = URL.createObjectURL(blob);
        const a = document.createElement('a');
        a.href = url;
        a.download = `moneyballs-${new Date().toISOString().split('T')[0]}.json`;
        a.click();
        URL.revokeObjectURL(url);
      }, [teamCount, rrGames, rrPointTarget, winnersCount, teams, seedingScores, bracketScores, bracketOverrides, matchupsGenerated, game1Matchups, game2Matchups, game3Matchups, pools, onCourt, bracketSeedOverride]);

      const loadProgress = useCallback((e) => {
        const file = e.target.files[0];
        if (!file) return;
        const reader = new FileReader();
        reader.onload = (event) => {
          try {
            const data = JSON.parse(event.target.result);
            if (data.teamCount) setTeamCount(data.teamCount);
            if (data.rrGames) setRrGames(data.rrGames);
            if (data.rrPointTarget) setRrPointTarget(data.rrPointTarget);
            if (data.winnersCount) setWinnersCount(data.winnersCount);
            if (data.teams) setTeams(data.teams);
            if (data.seedingScores) setSeedingScores(data.seedingScores);
            if (data.bracketScores) setBracketScores(data.bracketScores);
            if (data.bracketOverrides) setBracketOverrides(data.bracketOverrides);
            if (data.game1Matchups) setGame1Matchups(data.game1Matchups);
            if (data.game2Matchups) setGame2Matchups(data.game2Matchups);
            if (data.game3Matchups) setGame3Matchups(data.game3Matchups);
            if (data.pools) setPools(data.pools);
            if (data.matchupsGenerated) setMatchupsGenerated(data.matchupsGenerated);
            if (data.onCourt) setOnCourt(data.onCourt);
            // Clear overrides on load so standings recalculate from seeding scores
            setBracketSeedOverride(null);
            setStandingsOverride(null);

            // Auto-detect the right phase
            const hasBracketData = data.bracketScores && Object.keys(data.bracketScores).length > 0;
            const hasBracketOverrides = data.bracketOverrides && Object.keys(data.bracketOverrides).length > 0;
            const hasOnCourtBracket = data.onCourt && Object.keys(data.onCourt).some(k => k.startsWith('w') || k.startsWith('l') || k === 'gf');
            if (hasBracketData || hasBracketOverrides || hasOnCourtBracket) {
              setPhase('bracket');
            } else if (data.seedingScores && Object.keys(data.seedingScores).length > 0) {
              const totalExpected = (data.rrGames || 3) * Math.floor((data.teamCount || 16) / 2);
              const totalScored = Object.values(data.seedingScores).filter(s => s.s1 !== '' && s.s2 !== '' && s.s1 !== undefined && s.s2 !== undefined).length;
              if (totalScored >= totalExpected) {
                setPhase('bracket');
              } else {
                setPhase('roundrobin');
              }
            } else if (data.matchupsGenerated) {
              setPhase('roundrobin');
            } else if (data.teams && data.teams.some(t => t.p1Name)) {
              setPhase('setup');
            } else {
              setPhase('import');
            }
          } catch (err) {
            alert('Invalid file');
          }
        };
        reader.readAsText(file);
      }, []);

      const downloadResults = useCallback(() => {
        const winner = getBracketMatchTeam('gf');
        const second = getBracketMatchLoser('gf');
        const third = getBracketMatchLoser('lf');
        const date = new Date().toLocaleDateString('en-US', { year: 'numeric', month: 'long', day: 'numeric' });

        let results = `JORDAN'S MONEYBALLS - ${date}\n`;
        results += `==================================================\n\n`;
        results += `üèÜ FINAL STANDINGS (BRACKET)\n`;
        results += `------------------------------\n`;
        results += `ü•á 1st: ${winner ? winner.name : 'TBD'}\n`;
        results += `ü•à 2nd: ${second ? second.name : 'TBD'}\n`;
        results += `ü•â 3rd: ${third ? third.name : 'TBD'}\n\n`;

        results += `TEAMS (INITIAL SEEDING)\n`;
        results += `------------------------------\n`;
        teams.forEach((t, i) => {
          results += `${i + 1}. ${getTeamName(t)}${getTeamDupr(t) ? ` (${getTeamDupr(t)})` : ''}\n`;
        });

        results += `\n==================================================\n`;
        results += `ROUND ROBIN SCORES\n`;
        results += `==================================================\n\n`;

        results += `GAME 1\n`;
        results += `------------------------------\n`;
        seedingMatches.game1.forEach(m => {
          const score = seedingScores[m.id];
          if (score && score.s1 !== undefined && score.s2 !== undefined) {
            const s1Won = parseInt(score.s1) > parseInt(score.s2);
            results += `${s1Won ? '‚úì' : ' '} ${m.t1.name} ${score.s1}-${score.s2} ${m.t2.name} ${!s1Won ? '‚úì' : ''}\n`;
          }
        });

        results += `\nGAME 2\n`;
        results += `------------------------------\n`;
        seedingMatches.game2.forEach(m => {
          const score = seedingScores[m.id];
          if (score && score.s1 !== undefined && score.s2 !== undefined) {
            const s1Won = parseInt(score.s1) > parseInt(score.s2);
            results += `${s1Won ? '‚úì' : ' '} ${m.t1.name} ${score.s1}-${score.s2} ${m.t2.name} ${!s1Won ? '‚úì' : ''}\n`;
          }
        });

        if (seedingMatches.game3.length > 0) {
          results += `\nGAME 3\n`;
          results += `------------------------------\n`;
          seedingMatches.game3.forEach(m => {
            const score = seedingScores[m.id];
            if (score && score.s1 !== undefined && score.s2 !== undefined) {
              const s1Won = parseInt(score.s1) > parseInt(score.s2);
              results += `${s1Won ? '‚úì' : ' '} ${m.t1.name} ${score.s1}-${score.s2} ${m.t2.name} ${!s1Won ? '‚úì' : ''}\n`;
            }
          });
        }

        results += `\nROUND ROBIN STANDINGS\n`;
        results += `------------------------------\n`;
        displayStandings.forEach((t, i) => {
          const bracket = i < winnersCount ? '‚Üí Winners' : '‚Üí Losers';
          results += `${i + 1}. ${t.name} ${t.wins}-${t.losses} (${t.pf - t.pa >= 0 ? '+' : ''}${t.pf - t.pa}) ${bracket}\n`;
        });

        results += `\n==================================================\n`;
        results += `BRACKET SCORES\n`;
        results += `==================================================\n\n`;

        const formatBracketMatch = (id, label) => {
          const match = bracketMatches[id];
          const score = bracketScores[id];
          if (!match || !match.t1 || !match.t2) return '';
          if (!score) return `${label}: ${match.t1.name} vs ${match.t2.name} - Not played\n`;

          if (match.bo3 && score.games && score.games.length > 0) {
            const gameScores = score.games.map(g => `${g.s1}-${g.s2}`).join(', ');
            const t1Wins = score.games.filter(g => g.s1 > g.s2).length;
            const t2Wins = score.games.filter(g => g.s2 > g.s1).length;
            const winner = t1Wins > t2Wins ? match.t1.name : match.t2.name;
            return `${label}: ${match.t1.name} vs ${match.t2.name} (${gameScores}) ‚Üí ${winner}\n`;
          } else if (score.s1 !== undefined && score.s2 !== undefined) {
            const winner = parseInt(score.s1) > parseInt(score.s2) ? match.t1.name : match.t2.name;
            return `${label}: ${match.t1.name} ${score.s1}-${score.s2} ${match.t2.name} ‚Üí ${winner}\n`;
          }
          return '';
        };

        results += `WINNERS BRACKET\n`;
        results += `------------------------------\n`;
        ['wqf1', 'wqf2', 'wqf3', 'wqf4'].forEach(id => results += formatBracketMatch(id, 'W-QF'));
        ['wsf1', 'wsf2'].forEach(id => results += formatBracketMatch(id, 'W-SF'));
        results += formatBracketMatch('wf', 'W-Final (Bo3)');

        results += `\nLOSERS BRACKET\n`;
        results += `------------------------------\n`;
        ['lr1m1', 'lr1m2', 'lr1m3', 'lr1m4'].forEach(id => results += formatBracketMatch(id, 'L-R1'));
        ['lr2m1', 'lr2m2', 'lr2m3', 'lr2m4'].forEach(id => results += formatBracketMatch(id, 'L-R2'));
        ['lr3m1', 'lr3m2'].forEach(id => results += formatBracketMatch(id, 'L-R3'));
        ['lr4m1', 'lr4m2'].forEach(id => results += formatBracketMatch(id, 'L-R4'));
        results += formatBracketMatch('lsf', 'L-Semi');
        results += formatBracketMatch('lf', 'L-Final');

        results += `\nGRAND FINAL (Bo3)\n`;
        results += `------------------------------\n`;
        results += formatBracketMatch('gf', 'Grand Final');

        const blob = new Blob([results], { type: 'text/plain' });
        const url = URL.createObjectURL(blob);
        const a = document.createElement('a');
        a.href = url;
        a.download = `moneyballs-results-${new Date().toISOString().split('T')[0]}.txt`;
        a.click();
        URL.revokeObjectURL(url);
      }, [teams, displayStandings, seedingMatches, seedingScores, bracketMatches, bracketScores, getTeamName, getTeamDupr, getBracketMatchTeam, getBracketMatchLoser]);

      const gfWinner = getBracketMatchTeam('gf');

      return (
        <div className="bg-gray-900 text-white p-4 min-h-screen">
          <h1 className="text-2xl font-bold text-center mb-2">üèì Jordan's Moneyballs</h1>

          {spectatorMode && (
            <div className="bg-blue-900 border border-blue-500 text-blue-200 text-center py-2 px-4 rounded mb-3 max-w-md mx-auto">
              üëÅÔ∏è Spectator Mode - View Only
            </div>
          )}

          {!spectatorMode && (
            <div className="flex justify-center gap-2 mb-2">
              <button onClick={saveProgress} className="text-xs bg-gray-700 px-2 py-1 rounded hover:bg-gray-600">üíæ Save</button>
              <label className="text-xs bg-gray-700 px-2 py-1 rounded hover:bg-gray-600 cursor-pointer">
                üìÇ Load
                <input type="file" accept=".json" className="hidden" onChange={loadProgress} />
              </label>
              <button onClick={shareLink} className={`text-xs px-2 py-1 rounded ${linkCopied ? 'bg-green-600' : 'bg-blue-600 hover:bg-blue-500'}`}>
                {linkCopied ? '‚úì Copied!' : 'üîó Share Link'}
              </button>
            </div>
          )}

          <div className="flex justify-center gap-2 mb-4 flex-wrap">
            <button onClick={() => setPhase('import')} className={`px-3 py-1 rounded text-sm ${phase === 'import' ? 'bg-orange-600' : 'bg-gray-700'}`}>Import</button>
            <button onClick={() => setPhase('setup')} className={`px-3 py-1 rounded text-sm ${phase === 'setup' ? 'bg-purple-600' : 'bg-gray-700'}`} disabled={!teamsValid}>Setup</button>
            <button onClick={() => setPhase('roundrobin')} className={`px-3 py-1 rounded text-sm ${phase === 'roundrobin' ? 'bg-blue-600' : 'bg-gray-700'}`} disabled={!matchupsGenerated}>Round Robin</button>
            <button onClick={() => setPhase('standings')} className={`px-3 py-1 rounded text-sm ${phase === 'standings' ? 'bg-cyan-600' : 'bg-gray-700'}`} disabled={!matchupsGenerated}>Standings</button>
            <button onClick={() => setPhase('bracket')} className={`px-3 py-1 rounded text-sm ${phase === 'bracket' ? 'bg-green-600' : 'bg-gray-700'}`} disabled={!allSeedingComplete}>Bracket</button>
            <button onClick={() => setPhase('results')} className={`px-3 py-1 rounded text-sm ${phase === 'results' ? 'bg-yellow-600' : 'bg-gray-700'}`} disabled={!gfWinner}>Results</button>
          </div>

          {phase === 'import' && (
            <div className="max-w-2xl mx-auto">
              <h2 className="text-xl font-semibold mb-4 text-center">Import Teams</h2>
              <div className="flex justify-center items-center gap-4 mb-4">
                <label className="text-sm text-gray-300">Teams:</label>
                <select
                  value={teamCount}
                  onChange={(e) => {
                    const newCount = parseInt(e.target.value);
                    setTeamCount(newCount);
                    setWinnersCount(defaultWinnersCount[newCount] || 8);
                  }}
                  className="bg-gray-700 border border-gray-600 rounded px-3 py-1 text-sm"
                >
                  {[12, 13, 14, 15, 16].map(n => (
                    <option key={n} value={n}>{n}</option>
                  ))}
                </select>
              </div>
              <textarea
                className="w-full h-72 bg-gray-800 border border-gray-600 rounded p-3 text-sm font-mono"
                placeholder="Player 1 / Player 2&#10;Player 3 / Player 4&#10;...etc"
                value={importText}
                onChange={(e) => {
                  setImportText(e.target.value);
                  // Auto-detect team count from pasted text
                  const lines = e.target.value.split('\n').filter(l => l.trim() && l.includes('/'));
                  if (lines.length >= 12 && lines.length <= 16) {
                    setTeamCount(lines.length);
                    setWinnersCount(defaultWinnersCount[lines.length] || 8);
                  }
                }}
              />
              <button onClick={parseImportText} className="w-full mt-4 bg-orange-600 hover:bg-orange-500 py-2 rounded font-semibold">
                Import {teamCount} Teams ‚Üí
              </button>
            </div>
          )}

          {phase === 'setup' && (
            <div className="max-w-4xl mx-auto">
              <h2 className="text-xl font-semibold mb-2 text-center">Teams ({teamCount})</h2>
              <p className="text-gray-400 text-xs text-center mb-1">Drag teams to reorder seeding</p>
              <p className="text-xs text-center mb-4">
                <span className={teams.filter(t => t.p1Paid && t.p2Paid).length === teamCount ? 'text-green-400' : 'text-yellow-400'}>
                  {teams.reduce((n, t) => n + (t.p1Paid ? 1 : 0) + (t.p2Paid ? 1 : 0), 0)}/{teamCount * 2} paid
                </span>
              </p>
              <div className="grid md:grid-cols-2 gap-4">
                <div>
                  <h3 className="text-yellow-400 font-semibold mb-2">Seeds 1-4</h3>
                  {[0, 1, 2, 3].filter(i => i < teamCount).map(i => (
                    <TeamInput
                      key={`team-${i}`}
                      index={i}
                      color="text-yellow-400"
                      team={teams[i]}
                      dupr={getTeamDupr(teams[i])}
                      onChange={(field, value) => handleTeamChange(i, field, value)}
                      onDragStart={handleDragStart}
                      onDragOver={handleDragOver}
                      onDrop={handleDrop}
                      isDragging={dragIndex === i}
                      isDragOver={dragOverIndex === i}
                    />
                  ))}
                  <h3 className="text-blue-400 font-semibold mb-2 mt-4">Seeds 5-8</h3>
                  {[4, 5, 6, 7].filter(i => i < teamCount).map(i => (
                    <TeamInput
                      key={`team-${i}`}
                      index={i}
                      color="text-blue-400"
                      team={teams[i]}
                      dupr={getTeamDupr(teams[i])}
                      onChange={(field, value) => handleTeamChange(i, field, value)}
                      onDragStart={handleDragStart}
                      onDragOver={handleDragOver}
                      onDrop={handleDrop}
                      isDragging={dragIndex === i}
                      isDragOver={dragOverIndex === i}
                    />
                  ))}
                </div>
                <div>
                  <h3 className="text-green-400 font-semibold mb-2">Seeds 9-12</h3>
                  {[8, 9, 10, 11].filter(i => i < teamCount).map(i => (
                    <TeamInput
                      key={`team-${i}`}
                      index={i}
                      color="text-green-400"
                      team={teams[i]}
                      dupr={getTeamDupr(teams[i])}
                      onChange={(field, value) => handleTeamChange(i, field, value)}
                      onDragStart={handleDragStart}
                      onDragOver={handleDragOver}
                      onDrop={handleDrop}
                      isDragging={dragIndex === i}
                      isDragOver={dragOverIndex === i}
                    />
                  ))}
                  {teamCount > 12 && (
                    <>
                      <h3 className="text-red-400 font-semibold mb-2 mt-4">Seeds 13-{teamCount}</h3>
                      {[12, 13, 14, 15].filter(i => i < teamCount).map(i => (
                        <TeamInput
                          key={`team-${i}`}
                          index={i}
                          color="text-red-400"
                          team={teams[i]}
                          dupr={getTeamDupr(teams[i])}
                          onChange={(field, value) => handleTeamChange(i, field, value)}
                          onDragStart={handleDragStart}
                          onDragOver={handleDragOver}
                          onDrop={handleDrop}
                          isDragging={dragIndex === i}
                          isDragOver={dragOverIndex === i}
                        />
                      ))}
                    </>
                  )}
                </div>
              </div>
              {teamsValid && !spectatorMode && (
                <div className="mt-4">
                  <div className="bg-gray-800 rounded p-3 mb-3">
                    <div className="flex items-center justify-between">
                      <span className="text-sm">RR Games:</span>
                      <div className="flex items-center gap-2">
                        <select
                          value={rrGames}
                          onChange={(e) => setRrGames(parseInt(e.target.value))}
                          className="bg-gray-700 rounded px-2 py-1 text-sm"
                        >
                          <option value={2}>2 games (seed-balanced)</option>
                          <option value={3}>3 games {teamCount === 12 || teamCount === 16 ? '(pools)' : '(random)'}</option>
                        </select>
                        <span className="text-gray-500">to</span>
                        <select
                          value={rrPointTarget}
                          onChange={(e) => setRrPointTarget(parseInt(e.target.value))}
                          className="bg-gray-700 rounded px-2 py-1 text-sm"
                        >
                          <option value={11}>11</option>
                          <option value={15}>15</option>
                        </select>
                      </div>
                    </div>
                    <div className="text-xs text-gray-500 mt-1">
                      {rrGames === 2
                        ? `Each team plays 2 games to ${rrPointTarget} vs similar seeds`
                        : teamCount === 12 || teamCount === 16
                          ? `${teamCount === 12 ? '3' : '4'} pools of 4, games to ${rrPointTarget}`
                          : `Each team plays 3 random opponents to ${rrPointTarget}`}
                    </div>
                  </div>
                  <div className="bg-gray-800 rounded p-3 mb-3">
                    <div className="flex items-center justify-between">
                      <span className="text-sm">Winners Bracket Size:</span>
                      <div className="flex items-center gap-2">
                        <select
                          value={winnersCount}
                          onChange={(e) => setWinnersCount(parseInt(e.target.value))}
                          className="bg-gray-700 rounded px-2 py-1 text-sm"
                        >
                          {Array.from({ length: teamCount - 3 }, (_, i) => i + 4).map(n => (
                            <option key={n} value={n}>{n} teams</option>
                          ))}
                          <option value={teamCount}>{teamCount} (all)</option>
                        </select>
                        <button
                          onClick={() => setWinnersCount(defaultWinnersCount[teamCount] || 8)}
                          className="text-xs text-gray-400 hover:text-white"
                        >
                          Reset
                        </button>
                      </div>
                    </div>
                    <div className="text-xs text-gray-500 mt-1">
                      {winnersCount === teamCount
                        ? 'All teams start in Winners Bracket (losers drop to Losers Bracket)'
                        : `Top ${winnersCount} ‚Üí Winners, Bottom ${teamCount - winnersCount} ‚Üí Losers`}
                    </div>
                  </div>
                  <button onClick={generateRandomMatchups} className="w-full bg-yellow-600 hover:bg-yellow-500 py-2 rounded font-semibold mb-2">
                    üé≤ Randomize Matchups
                  </button>
                  {matchupsGenerated && (
                    <button onClick={() => setPhase('roundrobin')} className="w-full bg-blue-600 py-2 rounded font-semibold">
                      Start Round Robin ‚Üí
                    </button>
                  )}
                </div>
              )}
            </div>
          )}

          {phase === 'roundrobin' && (
            <div className="max-w-6xl mx-auto">
              <div className="flex justify-between items-center mb-2">
                <h2 className="text-xl font-semibold">Round Robin ({teamCount} teams, {rrGames} games to {rrPointTarget})</h2>
                {!spectatorMode && <button onClick={generateFakeSeedingScores} className="text-xs bg-purple-700 hover:bg-purple-600 px-2 py-1 rounded">üé≤ Test Scores</button>}
              </div>
              {!spectatorMode && <CourtStatus onCourtMatches={onCourtMatches} nextUpMatches={nextUpMatches} onToggleCourt={toggleOnCourt} />}

              {Object.keys(pools).length > 0 && (
                <div className="mb-4 bg-gray-800 rounded p-3">
                  <div className="text-sm font-semibold mb-2">Pool Assignments (Snake Draft)</div>
                  <div className={`grid ${teamCount === 12 ? 'md:grid-cols-3' : 'md:grid-cols-4'} gap-2 text-xs`}>
                    {Array.from({ length: teamCount === 12 ? 3 : 4 }, (_, poolIdx) => (
                      <div key={poolIdx} className="bg-gray-700 rounded p-2">
                        <div className="font-semibold text-center mb-1" style={{ color: ['#facc15', '#60a5fa', '#4ade80', '#f87171'][poolIdx] }}>
                          Pool {String.fromCharCode(65 + poolIdx)}
                        </div>
                        {Object.entries(pools).filter(([_, p]) => p === poolIdx).map(([teamIdx]) => (
                          <div key={teamIdx} className="text-gray-300 mb-1">
                            <span className="font-mono">{parseInt(teamIdx) + 1}.</span> {teams[teamIdx]?.p1Name?.split(' ')[0]} / {teams[teamIdx]?.p2Name?.split(' ')[0]}
                          </div>
                        ))}
                      </div>
                    ))}
                  </div>
                </div>
              )}

              {/* Pool-based layout for 12/16 teams with 3 games */}
              {Object.keys(pools).length > 0 ? (
                <div className={`grid ${teamCount === 12 ? 'md:grid-cols-3' : 'md:grid-cols-4'} gap-4`}>
                  {Array.from({ length: teamCount === 12 ? 3 : 4 }, (_, poolIdx) => {
                    const poolColor = ['#facc15', '#60a5fa', '#4ade80', '#f87171'][poolIdx];
                    const poolMatches = (game, gameNum) => game.filter(m => pools[m.t1.seed - 1] === poolIdx);
                    return (
                      <div key={poolIdx}>
                        <h3 className="font-semibold mb-2 text-center" style={{ color: poolColor }}>
                          Pool {String.fromCharCode(65 + poolIdx)}
                        </h3>
                        <div className="space-y-2">
                          {[
                            { matches: poolMatches(seedingMatches.game1), label: 'Game 1' },
                            { matches: poolMatches(seedingMatches.game2), label: 'Game 2' },
                            { matches: poolMatches(seedingMatches.game3), label: 'Game 3' }
                          ].map(({ matches, label }) => matches.map(m => (
                            <div key={m.id}>
                              <div className="text-xs text-gray-500 mb-1">{label}</div>
                              <SeedingMatch
                                match={m}
                                score={seedingScores[m.id] || {}}
                                isOnCourt={onCourt[m.id]}
                                onScoreChange={(field, value) => handleSeedingScore(m.id, field, value)}
                                onToggleCourt={() => toggleOnCourt(m.id)}
                                readOnly={spectatorMode}
                              />
                            </div>
                          )))}
                        </div>
                      </div>
                    );
                  })}
                </div>
              ) : (
                /* Game-based layout for seed-balanced or random matchups */
                <div className={`grid ${seedingMatches.game3.length > 0 ? 'md:grid-cols-3' : 'md:grid-cols-2'} gap-4`}>
                  <div>
                    <h3 className="text-blue-400 font-semibold mb-2 text-center">Game 1</h3>
                    <div className="space-y-2">
                      {seedingMatches.game1.map(m => (
                        <SeedingMatch
                          key={m.id}
                          match={m}
                          score={seedingScores[m.id] || {}}
                          isOnCourt={onCourt[m.id]}
                          onScoreChange={(field, value) => handleSeedingScore(m.id, field, value)}
                          onToggleCourt={() => toggleOnCourt(m.id)}
                          readOnly={spectatorMode}
                        />
                      ))}
                    </div>
                  </div>
                  <div>
                    <h3 className="text-green-400 font-semibold mb-2 text-center">Game 2</h3>
                    <div className="space-y-2">
                      {seedingMatches.game2.map(m => (
                        <SeedingMatch
                          key={m.id}
                          match={m}
                          score={seedingScores[m.id] || {}}
                          isOnCourt={onCourt[m.id]}
                          onScoreChange={(field, value) => handleSeedingScore(m.id, field, value)}
                          onToggleCourt={() => toggleOnCourt(m.id)}
                          readOnly={spectatorMode}
                        />
                      ))}
                    </div>
                  </div>
                  {seedingMatches.game3.length > 0 && (
                    <div>
                      <h3 className="text-yellow-400 font-semibold mb-2 text-center">Game 3</h3>
                      <div className="space-y-2">
                        {seedingMatches.game3.map(m => (
                          <SeedingMatch
                            key={m.id}
                            match={m}
                            score={seedingScores[m.id] || {}}
                            isOnCourt={onCourt[m.id]}
                            onScoreChange={(field, value) => handleSeedingScore(m.id, field, value)}
                            onToggleCourt={() => toggleOnCourt(m.id)}
                            readOnly={spectatorMode}
                          />
                        ))}
                      </div>
                    </div>
                  )}
                </div>
              )}
              {allSeedingComplete && (
                <button onClick={() => setPhase('bracket')} className="w-full mt-4 bg-green-600 py-2 rounded font-semibold">
                  Start Bracket ‚Üí
                </button>
              )}
            </div>
          )}

          {phase === 'standings' && (
            <div className="max-w-2xl mx-auto">
              <div className="flex justify-between items-center mb-4">
                <h2 className="text-xl font-semibold text-center flex-1">Live Standings</h2>
                {!spectatorMode && (
                  <div className="flex items-center gap-2">
                    {standingsOverride && (
                      <button onClick={() => { setStandingsOverride(null); setBracketSeedOverride(null); }} className="text-xs bg-gray-700 px-2 py-1 rounded hover:bg-gray-600">Reset Order</button>
                    )}
                  </div>
                )}
              </div>
              {standingsOverride && (
                <div className="mb-2 bg-yellow-900/30 border border-yellow-600 rounded px-3 py-1 text-xs text-yellow-300 text-center">
                  Manual order applied ‚Äî drag to reorder, or Reset to recalculate
                </div>
              )}
              <p className="text-gray-500 text-xs text-center mb-2">Drag rows to manually reorder</p>
              <div className="bg-gray-800 rounded p-3">
                <div className="text-xs text-gray-500 flex px-2 mb-2">
                  <span className="w-6"></span>
                  <span className="w-8">Rk</span>
                  {Object.keys(pools).length > 0 && <span className="w-10">Pool</span>}
                  <span className="flex-1">Team</span>
                  <span className="w-12 text-center">W-L</span>
                  <span className="w-12 text-center">PF</span>
                  <span className="w-12 text-center">PA</span>
                  <span className="w-12 text-right">PD</span>
                </div>
                {displayStandings.map((t, i) => {
                  const isWinners = i < winnersCount;
                  const poolColors = ['text-yellow-400', 'text-blue-400', 'text-green-400', 'text-red-400'];
                  return (
                    <div
                      key={t.seed}
                      draggable={!spectatorMode}
                      onDragStart={(e) => handleStandingsDragStart(e, i)}
                      onDragOver={(e) => handleStandingsDragOver(e, i)}
                      onDrop={(e) => handleStandingsDrop(e, i)}
                      onDragEnd={() => { setStandingsDragIndex(null); setStandingsDragOverIndex(null); }}
                      className={`flex items-center text-sm py-2 px-2 rounded mb-1 transition-all ${
                        standingsDragOverIndex === i ? 'border-2 border-yellow-400' : 'border-2 border-transparent'
                      } ${standingsDragIndex === i ? 'opacity-50' : ''} ${isWinners ? 'bg-blue-900/30' : 'bg-red-900/30'} ${!spectatorMode ? 'cursor-move' : ''}`}
                    >
                      {!spectatorMode && <span className="w-6 text-gray-600 text-xs">‚ò∞</span>}
                      <span className={`w-8 font-bold ${isWinners ? 'text-blue-400' : 'text-red-400'}`}>{i + 1}</span>
                      {Object.keys(pools).length > 0 && (
                        <span className={`w-10 text-xs ${poolColors[t.pool] || 'text-gray-400'}`}>
                          {t.pool !== undefined ? String.fromCharCode(65 + t.pool) : '-'}
                        </span>
                      )}
                      <span className="flex-1 truncate">{t.name}</span>
                      <span className="w-12 text-center">{t.wins}-{t.losses}</span>
                      <span className="w-12 text-center text-gray-400">{t.pf}</span>
                      <span className="w-12 text-center text-gray-400">{t.pa}</span>
                      <span className={`w-12 text-right ${t.pf - t.pa > 0 ? 'text-green-400' : t.pf - t.pa < 0 ? 'text-red-400' : ''}`}>
                        {t.pf - t.pa > 0 ? '+' : ''}{t.pf - t.pa}
                      </span>
                    </div>
                  );
                })}
              </div>
              <div className="mt-2 text-xs text-gray-500 text-center">
                {winnersCount === teamCount
                  ? `All ${teamCount} teams ‚Üí Winners Bracket`
                  : `Top ${winnersCount} ‚Üí Winners Bracket | Bottom ${teamCount - winnersCount} ‚Üí Losers Bracket`}
              </div>
              {allSeedingComplete && (
                <button onClick={() => setPhase('bracket')} className="w-full mt-4 bg-green-600 py-2 rounded font-semibold">
                  Start Bracket ‚Üí
                </button>
              )}
            </div>
          )}

          {phase === 'bracket' && (
            <div className="max-w-6xl mx-auto overflow-x-auto">
              {!spectatorMode && <CourtStatus onCourtMatches={onCourtMatches} nextUpMatches={nextUpMatches} onToggleCourt={toggleOnCourt} />}

              {bracketSwaps.length > 0 && (
                <div className="mb-3 bg-yellow-900/50 border border-yellow-600 rounded p-2 text-sm">
                  <div className="font-semibold text-yellow-400 mb-1">üîÑ Seeding Adjusted (No Pool Rematches in R1)</div>
                  {bracketSwaps.map((swap, i) => (
                    <div key={i} className="text-yellow-200 text-xs">{swap}</div>
                  ))}
                </div>
              )}

              <div className="flex justify-between items-center mb-2">
                <h2 className="text-lg font-semibold text-blue-400">Winners Bracket</h2>
                {!spectatorMode && (
                  <div className="flex items-center gap-3">
                    <button onClick={generateFakeBracketScores} className="text-xs bg-purple-700 hover:bg-purple-600 px-2 py-1 rounded">üé≤ Test Scores</button>
                    <label className="text-xs text-gray-500 flex items-center gap-1">
                      <input type="checkbox" checked={showOverride} onChange={(e) => setShowOverride(e.target.checked)} />
                      Override
                    </label>
                  </div>
                )}
              </div>

              {showOverride && !spectatorMode && bracketTeams.winners.length > 0 && (
                <div className="mb-3 bg-gray-800 rounded p-3">
                  <div className="flex justify-between items-center mb-2">
                    <span className="text-sm font-semibold">Flip Bracket Seeds</span>
                    <div className="flex gap-2">
                      {selectedSwapTeam && <span className="text-xs text-yellow-400">Click another team to swap</span>}
                      {bracketSeedOverride && (
                        <button onClick={() => { setBracketSeedOverride(null); setBracketScores({}); setBracketOverrides({}); setSelectedSwapTeam(null); }} className="text-xs text-gray-400 hover:text-white bg-gray-700 px-2 py-0.5 rounded">Reset Seeds</button>
                      )}
                    </div>
                  </div>
                  <div className="grid grid-cols-2 gap-4">
                    <div>
                      <div className="text-xs text-blue-400 mb-1 font-semibold">Winners Bracket</div>
                      {bracketTeams.winners.map((t, i) => {
                        const isSelected = selectedSwapTeam?.side === 'winners' && selectedSwapTeam?.pos === i;
                        const matchups = [[0,7],[3,4],[1,6],[2,5]];
                        const matchup = matchups.find(m => m[0] === i || m[1] === i);
                        const oppIdx = matchup ? (matchup[0] === i ? matchup[1] : matchup[0]) : null;
                        return (
                          <div
                            key={t.seed}
                            className={`text-xs py-1 px-2 rounded cursor-pointer flex items-center gap-1 ${isSelected ? 'bg-yellow-600 text-white' : 'hover:bg-gray-700'}`}
                            onClick={() => handleSeedSwap('winners', i)}
                          >
                            <span className="font-mono w-6">W{i+1}.</span>
                            <span className="flex-1 truncate">{t.name.split(' / ').map(n => n.split(' ')[0]).join(' / ')}</span>
                            {oppIdx !== null && <span className="text-gray-500">vs W{oppIdx+1}</span>}
                          </div>
                        );
                      })}
                    </div>
                    <div>
                      <div className="text-xs text-red-400 mb-1 font-semibold">Losers Bracket</div>
                      {bracketTeams.losers.map((t, i) => {
                        const isSelected = selectedSwapTeam?.side === 'losers' && selectedSwapTeam?.pos === i;
                        const matchups = [[0,7],[3,4],[1,6],[2,5]];
                        const matchup = matchups.find(m => m[0] === i || m[1] === i);
                        const oppIdx = matchup ? (matchup[0] === i ? matchup[1] : matchup[0]) : null;
                        return (
                          <div
                            key={t.seed}
                            className={`text-xs py-1 px-2 rounded cursor-pointer flex items-center gap-1 ${isSelected ? 'bg-yellow-600 text-white' : 'hover:bg-gray-700'}`}
                            onClick={() => handleSeedSwap('losers', i)}
                          >
                            <span className="font-mono w-6">L{i+1}.</span>
                            <span className="flex-1 truncate">{t.name.split(' / ').map(n => n.split(' ')[0]).join(' / ')}</span>
                            {oppIdx !== null && <span className="text-gray-500">vs L{oppIdx+1}</span>}
                          </div>
                        );
                      })}
                    </div>
                  </div>
                </div>
              )}

              <div className="flex gap-3 pb-4">
                <div className="space-y-2 w-44 flex-shrink-0">
                  <div className="text-xs text-gray-500 text-center">W-QF</div>
                  {['wqf1', 'wqf2', 'wqf3', 'wqf4'].map(id => (
                    <BracketMatch
                      key={id}
                      match={bracketMatches[id]}
                      score={bracketScores[id] || {}}
                      override={bracketOverrides[id]}
                      isOnCourt={onCourt[id]}
                      showOverride={showOverride}
                      onScoreChange={(field, value) => handleBracketScore(id, bracketMatches[id]?.t1, bracketMatches[id]?.t2, field, value)}
                      onToggleCourt={() => toggleOnCourt(id)}
                      onOverride={(team) => handleBracketOverride(id, team, team === bracketMatches[id]?.t1 ? bracketMatches[id]?.t2 : bracketMatches[id]?.t1)}
                      onClearOverride={() => clearBracketOverride(id)}
                      winner={getBracketMatchTeam(id)}
                      readOnly={spectatorMode}
                    />
                  ))}
                </div>
                <div className="space-y-2 w-44 flex-shrink-0 pt-10">
                  <div className="text-xs text-gray-500 text-center">W-SF</div>
                  {['wsf1', 'wsf2'].map((id, idx) => (
                    <React.Fragment key={id}>
                      <BracketMatch
                        match={bracketMatches[id]}
                        score={bracketScores[id] || {}}
                        override={bracketOverrides[id]}
                        isOnCourt={onCourt[id]}
                        showOverride={showOverride}
                        onScoreChange={(field, value) => handleBracketScore(id, bracketMatches[id]?.t1, bracketMatches[id]?.t2, field, value)}
                        onToggleCourt={() => toggleOnCourt(id)}
                        onOverride={(team) => handleBracketOverride(id, team, team === bracketMatches[id]?.t1 ? bracketMatches[id]?.t2 : bracketMatches[id]?.t1)}
                        onClearOverride={() => clearBracketOverride(id)}
                        winner={getBracketMatchTeam(id)}
                        readOnly={spectatorMode}
                      />
                      {idx === 0 && <div className="h-12"></div>}
                    </React.Fragment>
                  ))}
                </div>
                <div className="w-44 flex-shrink-0 pt-20">
                  <div className="text-xs text-gray-500 text-center">W-Final</div>
                  <BracketMatch
                    match={bracketMatches.wf}
                    score={bracketScores.wf || {}}
                    override={bracketOverrides.wf}
                    isOnCourt={onCourt.wf}
                    showOverride={showOverride}
                    onScoreChange={(field, value) => handleBracketScore('wf', bracketMatches.wf?.t1, bracketMatches.wf?.t2, field, value)}
                    onBo3ScoreChange={(gi, field, value) => handleBo3Score('wf', bracketMatches.wf?.t1, bracketMatches.wf?.t2, gi, field, value)}
                    onToggleCourt={() => toggleOnCourt('wf')}
                    onOverride={(team) => handleBracketOverride('wf', team, team === bracketMatches.wf?.t1 ? bracketMatches.wf?.t2 : bracketMatches.wf?.t1)}
                    onClearOverride={() => clearBracketOverride('wf')}
                    winner={getBracketMatchTeam('wf')}
                    readOnly={spectatorMode}
                  />
                </div>
                <div className="w-56 flex-shrink-0 pt-16">
                  <h3 className="text-yellow-400 font-semibold mb-2 text-center text-sm">üèÜ Grand Final</h3>
                  <BracketMatch
                    match={bracketMatches.gf}
                    score={bracketScores.gf || {}}
                    override={bracketOverrides.gf}
                    isOnCourt={onCourt.gf}
                    showOverride={showOverride}
                    onScoreChange={(field, value) => handleBracketScore('gf', bracketMatches.gf?.t1, bracketMatches.gf?.t2, field, value)}
                    onBo3ScoreChange={(gi, field, value) => handleBo3Score('gf', bracketMatches.gf?.t1, bracketMatches.gf?.t2, gi, field, value)}
                    onToggleCourt={() => toggleOnCourt('gf')}
                    onOverride={(team) => handleBracketOverride('gf', team, team === bracketMatches.gf?.t1 ? bracketMatches.gf?.t2 : bracketMatches.gf?.t1)}
                    onClearOverride={() => clearBracketOverride('gf')}
                    winner={gfWinner}
                    readOnly={spectatorMode}
                  />
                  {gfWinner && (
                    <div className="mt-3 bg-gradient-to-r from-yellow-700 to-yellow-600 p-3 rounded text-center border-2 border-yellow-400">
                      <div className="text-xs text-yellow-200">ü•á CHAMPION</div>
                      {gfWinner.name.split(' / ').map((p, i) => (
                        <div key={i} className="text-sm font-bold text-white">{p}</div>
                      ))}
                    </div>
                  )}
                  {getBracketMatchLoser('gf') && (
                    <div className="mt-2 bg-gradient-to-r from-gray-500 to-gray-400 p-2 rounded text-center border border-gray-300">
                      <div className="text-xs text-gray-200">ü•à 2nd Place</div>
                      {getBracketMatchLoser('gf').name.split(' / ').map((p, i) => (
                        <div key={i} className="text-xs font-semibold text-white">{p}</div>
                      ))}
                    </div>
                  )}
                </div>
              </div>

              <h2 className="text-lg font-semibold text-red-400 mb-2">Losers Bracket</h2>
              <div className="flex gap-3 pb-4 overflow-x-auto">
                <div className="space-y-2 w-44 flex-shrink-0">
                  <div className="text-xs text-gray-500 text-center">L-R1</div>
                  {['lr1m1', 'lr1m2', 'lr1m3', 'lr1m4'].map(id => (
                    <BracketMatch
                      key={id}
                      match={bracketMatches[id]}
                      score={bracketScores[id] || {}}
                      override={bracketOverrides[id]}
                      isOnCourt={onCourt[id]}
                      showOverride={showOverride}
                      onScoreChange={(field, value) => handleBracketScore(id, bracketMatches[id]?.t1, bracketMatches[id]?.t2, field, value)}
                      onToggleCourt={() => toggleOnCourt(id)}
                      onOverride={(team) => handleBracketOverride(id, team, team === bracketMatches[id]?.t1 ? bracketMatches[id]?.t2 : bracketMatches[id]?.t1)}
                      onClearOverride={() => clearBracketOverride(id)}
                      winner={getBracketMatchTeam(id)}
                      readOnly={spectatorMode}
                    />
                  ))}
                </div>
                <div className="space-y-2 w-44 flex-shrink-0">
                  <div className="text-xs text-gray-500 text-center">L-R2</div>
                  {['lr2m1', 'lr2m2', 'lr2m3', 'lr2m4'].map(id => (
                    <BracketMatch
                      key={id}
                      match={bracketMatches[id]}
                      score={bracketScores[id] || {}}
                      override={bracketOverrides[id]}
                      isOnCourt={onCourt[id]}
                      showOverride={showOverride}
                      onScoreChange={(field, value) => handleBracketScore(id, bracketMatches[id]?.t1, bracketMatches[id]?.t2, field, value)}
                      onToggleCourt={() => toggleOnCourt(id)}
                      onOverride={(team) => handleBracketOverride(id, team, team === bracketMatches[id]?.t1 ? bracketMatches[id]?.t2 : bracketMatches[id]?.t1)}
                      onClearOverride={() => clearBracketOverride(id)}
                      winner={getBracketMatchTeam(id)}
                      readOnly={spectatorMode}
                    />
                  ))}
                </div>
                <div className="space-y-2 w-44 flex-shrink-0 pt-10">
                  <div className="text-xs text-gray-500 text-center">L-R3</div>
                  {['lr3m1', 'lr3m2'].map((id, idx) => (
                    <React.Fragment key={id}>
                      <BracketMatch
                        match={bracketMatches[id]}
                        score={bracketScores[id] || {}}
                        override={bracketOverrides[id]}
                        isOnCourt={onCourt[id]}
                        showOverride={showOverride}
                        onScoreChange={(field, value) => handleBracketScore(id, bracketMatches[id]?.t1, bracketMatches[id]?.t2, field, value)}
                        onToggleCourt={() => toggleOnCourt(id)}
                        onOverride={(team) => handleBracketOverride(id, team, team === bracketMatches[id]?.t1 ? bracketMatches[id]?.t2 : bracketMatches[id]?.t1)}
                        onClearOverride={() => clearBracketOverride(id)}
                        winner={getBracketMatchTeam(id)}
                        readOnly={spectatorMode}
                      />
                      {idx === 0 && <div className="h-6"></div>}
                    </React.Fragment>
                  ))}
                </div>
                <div className="space-y-2 w-44 flex-shrink-0 pt-10">
                  <div className="text-xs text-gray-500 text-center">L-R4</div>
                  {['lr4m1', 'lr4m2'].map((id, idx) => (
                    <React.Fragment key={id}>
                      <BracketMatch
                        match={bracketMatches[id]}
                        score={bracketScores[id] || {}}
                        override={bracketOverrides[id]}
                        isOnCourt={onCourt[id]}
                        showOverride={showOverride}
                        onScoreChange={(field, value) => handleBracketScore(id, bracketMatches[id]?.t1, bracketMatches[id]?.t2, field, value)}
                        onToggleCourt={() => toggleOnCourt(id)}
                        onOverride={(team) => handleBracketOverride(id, team, team === bracketMatches[id]?.t1 ? bracketMatches[id]?.t2 : bracketMatches[id]?.t1)}
                        onClearOverride={() => clearBracketOverride(id)}
                        winner={getBracketMatchTeam(id)}
                        readOnly={spectatorMode}
                      />
                      {idx === 0 && <div className="h-6"></div>}
                    </React.Fragment>
                  ))}
                </div>
                <div className="w-44 flex-shrink-0 pt-14">
                  <div className="text-xs text-gray-500 text-center">L-Semi</div>
                  <BracketMatch
                    match={bracketMatches.lsf}
                    score={bracketScores.lsf || {}}
                    override={bracketOverrides.lsf}
                    isOnCourt={onCourt.lsf}
                    showOverride={showOverride}
                    onScoreChange={(field, value) => handleBracketScore('lsf', bracketMatches.lsf?.t1, bracketMatches.lsf?.t2, field, value)}
                    onToggleCourt={() => toggleOnCourt('lsf')}
                    onOverride={(team) => handleBracketOverride('lsf', team, team === bracketMatches.lsf?.t1 ? bracketMatches.lsf?.t2 : bracketMatches.lsf?.t1)}
                    onClearOverride={() => clearBracketOverride('lsf')}
                    winner={getBracketMatchTeam('lsf')}
                    readOnly={spectatorMode}
                  />
                </div>
                <div className="w-44 flex-shrink-0 pt-14">
                  <div className="text-xs text-gray-500 text-center">L-Final</div>
                  <BracketMatch
                    match={bracketMatches.lf}
                    score={bracketScores.lf || {}}
                    override={bracketOverrides.lf}
                    isOnCourt={onCourt.lf}
                    showOverride={showOverride}
                    onScoreChange={(field, value) => handleBracketScore('lf', bracketMatches.lf?.t1, bracketMatches.lf?.t2, field, value)}
                    onToggleCourt={() => toggleOnCourt('lf')}
                    onOverride={(team) => handleBracketOverride('lf', team, team === bracketMatches.lf?.t1 ? bracketMatches.lf?.t2 : bracketMatches.lf?.t1)}
                    onClearOverride={() => clearBracketOverride('lf')}
                    winner={getBracketMatchTeam('lf')}
                    readOnly={spectatorMode}
                  />
                  {getBracketMatchTeam('lf') && (
                    <div className="mt-2 text-center">
                      <div className="text-xs text-yellow-400">‚Üó to Grand Final</div>
                    </div>
                  )}
                  {getBracketMatchLoser('lf') && (
                    <div className="mt-2 bg-gradient-to-r from-amber-800 to-amber-700 p-2 rounded text-center border border-amber-500">
                      <div className="text-xs text-amber-200">ü•â 3rd Place</div>
                      {getBracketMatchLoser('lf').name.split(' / ').map((p, i) => (
                        <div key={i} className="text-xs font-semibold text-white">{p}</div>
                      ))}
                    </div>
                  )}
                </div>
              </div>
            </div>
          )}

          {phase === 'results' && (
            <div className="max-w-2xl mx-auto">
              <h2 className="text-2xl font-bold text-center mb-6">üèÜ Final Results</h2>

              <div className="space-y-4">
                {gfWinner && (
                  <div className="bg-gradient-to-r from-yellow-700 to-yellow-600 p-6 rounded-lg border-2 border-yellow-400 text-center">
                    <div className="text-lg text-yellow-200">ü•á 1st Place</div>
                    {gfWinner.name.split(' / ').map((p, i) => (
                      <div key={i} className="text-2xl font-bold text-white">{p}</div>
                    ))}
                  </div>
                )}

                {getBracketMatchLoser('gf') && (
                  <div className="bg-gradient-to-r from-gray-500 to-gray-400 p-5 rounded-lg border-2 border-gray-300 text-center">
                    <div className="text-md text-gray-200">ü•à 2nd Place</div>
                    {getBracketMatchLoser('gf').name.split(' / ').map((p, i) => (
                      <div key={i} className="text-xl font-bold text-white">{p}</div>
                    ))}
                  </div>
                )}

                {getBracketMatchLoser('lf') && (
                  <div className="bg-gradient-to-r from-amber-800 to-amber-700 p-4 rounded-lg border-2 border-amber-500 text-center">
                    <div className="text-sm text-amber-200">ü•â 3rd Place</div>
                    {getBracketMatchLoser('lf').name.split(' / ').map((p, i) => (
                      <div key={i} className="text-lg font-bold text-white">{p}</div>
                    ))}
                  </div>
                )}
              </div>

              <div className="mt-8 text-center">
                <button onClick={downloadResults} className="bg-green-600 hover:bg-green-500 px-6 py-3 rounded-lg text-lg font-semibold">
                  üì• Download Full Results
                </button>
              </div>

            </div>
          )}
        </div>
      );
    }

    ReactDOM.createRoot(document.getElementById('root')).render(<App />);
  </script>
</body>
</html>
