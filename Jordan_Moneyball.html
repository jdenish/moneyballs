<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Jordan's Moneyballs</title>
  <script src="https://unpkg.com/react@18/umd/react.production.min.js"></script>
  <script src="https://unpkg.com/react-dom@18/umd/react-dom.production.min.js"></script>
  <script src="https://unpkg.com/@babel/standalone/babel.min.js"></script>
  <script src="https://cdn.tailwindcss.com"></script>
  <script src="https://unpkg.com/pako@2.1.0/dist/pako.min.js"></script>
</head>
<body>
  <div id="root"></div>
  <script type="text/babel">
    const { useState, useMemo, useCallback, memo } = React;

    // Move components outside App to prevent recreation on each render

    const SeedingMatch = memo(({ match, score, isOnCourt, onScoreChange, onToggleCourt, readOnly }) => {
      const isComplete = score.s1 !== undefined && score.s2 !== undefined && score.s1 !== '' && score.s2 !== '';
      const t1Won = isComplete && parseInt(score.s1) > parseInt(score.s2);
      const t2Won = isComplete && parseInt(score.s2) > parseInt(score.s1);

      return (
        <div className={`p-2 rounded border ${isComplete ? 'bg-gray-800 border-green-600' : isOnCourt ? 'bg-orange-900/50 border-orange-500' : 'bg-gray-800 border-gray-600'}`}>
          <div className="flex justify-between items-center mb-1">
            <span className="text-gray-500 text-xs">Court {match.court}</span>
            {!isComplete && !readOnly && (
              <button
                onClick={onToggleCourt}
                className={`text-xs px-2 py-0.5 rounded ${isOnCourt ? 'bg-orange-600' : 'bg-gray-700 hover:bg-orange-700'}`}
              >
                {isOnCourt ? 'üèì On Court' : 'Send'}
              </button>
            )}
          </div>
          <div className={`flex items-center gap-2 ${t1Won ? 'text-green-400' : 'text-gray-300'}`}>
            <span className="text-xs bg-gray-700 px-1 rounded">{match.t1.seed}</span>
            <span className="flex-1 text-sm truncate">{match.t1.name}</span>
            {readOnly ? (
              <span className="w-12 text-center text-sm font-mono">{score.s1 || '-'}</span>
            ) : (
              <input
                type="number"
                className="w-12 bg-gray-700 text-center rounded text-sm"
                value={score.s1 || ''}
                onChange={(e) => onScoreChange('s1', e.target.value)}
              />
            )}
          </div>
          <div className={`flex items-center gap-2 mt-1 ${t2Won ? 'text-green-400' : 'text-gray-300'}`}>
            <span className="text-xs bg-gray-700 px-1 rounded">{match.t2.seed}</span>
            <span className="flex-1 text-sm truncate">{match.t2.name}</span>
            {readOnly ? (
              <span className="w-12 text-center text-sm font-mono">{score.s2 || '-'}</span>
            ) : (
              <input
                type="number"
                className="w-12 bg-gray-700 text-center rounded text-sm"
                value={score.s2 || ''}
                onChange={(e) => onScoreChange('s2', e.target.value)}
              />
            )}
          </div>
        </div>
      );
    });

    const BracketMatch = memo(({ match, score, override, isOnCourt, showOverride, onScoreChange, onToggleCourt, onOverride, onClearOverride, winner, readOnly }) => {
      if (!match) return null;
      const t1 = match.t1;
      const t2 = match.t2;
      const isReady = t1 && t2;
      const hasBo3Games = score.games && score.games.length > 0;
      const isComplete = override || (isReady && (
        hasBo3Games ||
        (score.s1 !== undefined && score.s2 !== undefined && score.s1 !== '' && score.s2 !== '')
      ));
      const t1Won = winner && t1 && winner.seed === t1.seed;
      const t2Won = winner && t2 && winner.seed === t2.seed;

      return (
        <div className={`p-2 rounded border ${isComplete ? 'bg-gray-800 border-green-600' : isOnCourt ? 'bg-orange-900/50 border-orange-500' : isReady ? 'bg-gray-800 border-yellow-500' : 'bg-gray-800 border-gray-700'} ${match.bo3 ? 'ring-2 ring-yellow-500' : ''}`}>
          <div className="text-xs text-gray-500 mb-1 flex justify-between">
            <span>{match.round}</span>
            <div className="flex gap-1 items-center">
              {match.bo3 && <span className="text-yellow-400">Bo3</span>}
              {override && !readOnly && <span className="text-orange-400 cursor-pointer" onClick={onClearOverride}>‚ü≤</span>}
              {isReady && !isComplete && !readOnly && (
                <button
                  onClick={onToggleCourt}
                  className={`text-xs px-1 py-0.5 rounded ${isOnCourt ? 'bg-orange-600' : 'bg-gray-700 hover:bg-orange-700'}`}
                >
                  {isOnCourt ? 'üèì' : 'Send'}
                </button>
              )}
            </div>
          </div>
          <div className={`flex items-start gap-1 ${t1Won ? 'text-green-400 font-bold' : 'text-gray-300'}`}>
            <div className="flex-1 min-w-0">
              {t1 ? t1.name.split(' / ').map((p, i) => (
                <div key={i} className="text-xs leading-tight truncate">{p}</div>
              )) : <div className="text-xs">TBD</div>}
            </div>
            {hasBo3Games ? (
              <div className="flex gap-1 flex-shrink-0">
                {score.games.map((g, i) => (
                  <span key={i} className="w-7 bg-gray-700 text-center rounded text-sm">{g.s1}</span>
                ))}
              </div>
            ) : readOnly ? (
              <span className="w-10 text-center text-sm font-mono flex-shrink-0">{score.s1 || '-'}</span>
            ) : isReady && !override && (
              <input
                type="number"
                className="w-10 bg-gray-700 text-center rounded text-sm flex-shrink-0"
                value={score.s1 || ''}
                onChange={(e) => onScoreChange('s1', e.target.value)}
              />
            )}
            {showOverride && isReady && !override && !hasBo3Games && !readOnly && (
              <button className="text-xs bg-gray-700 px-1 rounded hover:bg-green-700 flex-shrink-0" onClick={() => onOverride(t1)}>W</button>
            )}
          </div>
          <div className={`flex items-start gap-1 mt-1 pt-1 border-t border-gray-700 ${t2Won ? 'text-green-400 font-bold' : 'text-gray-300'}`}>
            <div className="flex-1 min-w-0">
              {t2 ? t2.name.split(' / ').map((p, i) => (
                <div key={i} className="text-xs leading-tight truncate">{p}</div>
              )) : <div className="text-xs">TBD</div>}
            </div>
            {hasBo3Games ? (
              <div className="flex gap-1 flex-shrink-0">
                {score.games.map((g, i) => (
                  <span key={i} className="w-7 bg-gray-700 text-center rounded text-sm">{g.s2}</span>
                ))}
              </div>
            ) : readOnly ? (
              <span className="w-10 text-center text-sm font-mono flex-shrink-0">{score.s2 || '-'}</span>
            ) : isReady && !override && (
              <input
                type="number"
                className="w-10 bg-gray-700 text-center rounded text-sm flex-shrink-0"
                value={score.s2 || ''}
                onChange={(e) => onScoreChange('s2', e.target.value)}
              />
            )}
            {showOverride && isReady && !override && !hasBo3Games && !readOnly && (
              <button className="text-xs bg-gray-700 px-1 rounded hover:bg-green-700 flex-shrink-0" onClick={() => onOverride(t2)}>W</button>
            )}
          </div>
        </div>
      );
    });

    const TeamInput = memo(({ index, color, team, dupr, onChange, onDragStart, onDragOver, onDrop, isDragging, isDragOver }) => {
      return (
        <div
          draggable
          onDragStart={(e) => onDragStart(e, index)}
          onDragOver={(e) => onDragOver(e, index)}
          onDrop={(e) => onDrop(e, index)}
          onDragEnd={(e) => e.target.style.opacity = 1}
          className={`flex items-center gap-2 mb-2 bg-gray-800 p-2 rounded cursor-move border-2 transition-all ${
            isDragOver ? 'border-yellow-400 bg-gray-700' : 'border-transparent'
          } ${isDragging ? 'opacity-50' : ''}`}
        >
          <div className="flex flex-col items-center gap-1">
            <span className={`${color} w-5 font-bold text-sm text-center`}>{index + 1}</span>
            <span className="text-gray-500 text-xs">‚ò∞</span>
          </div>
          <div className="flex-1 flex flex-col gap-1">
            <div className="flex gap-1">
              <input
                className="flex-1 bg-gray-700 border border-gray-600 rounded px-2 py-1 text-sm"
                placeholder="Player 1"
                value={team.p1Name}
                onChange={(e) => onChange('p1Name', e.target.value)}
                onDragStart={(e) => e.stopPropagation()}
                draggable={false}
              />
              <input
                className="w-12 bg-gray-700 border border-gray-600 rounded px-1 py-1 text-xs text-center"
                placeholder="4.5"
                type="number"
                step="0.01"
                value={team.p1Dupr}
                onChange={(e) => onChange('p1Dupr', e.target.value)}
                onDragStart={(e) => e.stopPropagation()}
                draggable={false}
              />
            </div>
            <div className="flex gap-1">
              <input
                className="flex-1 bg-gray-700 border border-gray-600 rounded px-2 py-1 text-sm"
                placeholder="Player 2"
                value={team.p2Name}
                onChange={(e) => onChange('p2Name', e.target.value)}
                onDragStart={(e) => e.stopPropagation()}
                draggable={false}
              />
              <input
                className="w-12 bg-gray-700 border border-gray-600 rounded px-1 py-1 text-xs text-center"
                placeholder="4.5"
                type="number"
                step="0.01"
                value={team.p2Dupr}
                onChange={(e) => onChange('p2Dupr', e.target.value)}
                onDragStart={(e) => e.stopPropagation()}
                draggable={false}
              />
            </div>
          </div>
          <span className={`w-12 text-right text-sm font-mono font-bold ${dupr ? 'text-green-400' : 'text-gray-600'}`}>
            {dupr || '‚Äî'}
          </span>
        </div>
      );
    });

    const CourtStatus = memo(({ onCourtMatches, nextUpMatches, onToggleCourt }) => (
      <div className="mb-4 grid md:grid-cols-2 gap-2">
        <div className="bg-orange-900/30 border border-orange-500 rounded p-2">
          <div className="text-orange-400 text-xs font-semibold mb-1">üèì On Court ({onCourtMatches.length})</div>
          {onCourtMatches.length === 0 ? (
            <div className="text-gray-500 text-xs">No matches on court</div>
          ) : (
            <div className="space-y-1">
              {onCourtMatches.map(m => (
                <div key={m.id} className="text-xs text-orange-300">
                  {m.round || `Ct${m.court}`}: {m.t1?.name?.split('/')[0]} vs {m.t2?.name?.split('/')[0]}
                </div>
              ))}
            </div>
          )}
        </div>
        <div className="bg-gray-800 border border-gray-600 rounded p-2">
          <div className="text-gray-400 text-xs font-semibold mb-1">‚è≥ Next Up ({nextUpMatches.length})</div>
          {nextUpMatches.length === 0 ? (
            <div className="text-gray-500 text-xs">All done!</div>
          ) : (
            <div className="space-y-1">
              {nextUpMatches.slice(0, 4).map(m => (
                <div key={m.id} className="text-xs text-gray-300 flex justify-between">
                  <span>{m.round || `Ct${m.court}`}: {m.t1?.name?.split('/')[0]} vs {m.t2?.name?.split('/')[0]}</span>
                  <button onClick={() => onToggleCourt(m.id)} className="text-orange-400 hover:text-orange-300">Send‚Üí</button>
                </div>
              ))}
            </div>
          )}
        </div>
      </div>
    ));

    function App() {
      const [phase, setPhase] = useState('import');
      const [importText, setImportText] = useState(`Oscar Serra / Sanil Jagtiani
Jack Hared / Preston Gordon
Ted Holway / Alex Szczepkowski
Matvey Radionov / Matt Meadows
Lukas Choi / William Hayes
Jordan Denish / Alex Tong
Conor Landrigan / Geoff Watson
Cody Sadreameli / Dan Wach
Jeff Comer / Kenoa Tio
Matthew Matro / Zach Bowe
Bruno Casino Remondo / Drew Von Bargen
Austin Gow / Peter Weaver
Alex Boory / Ronald Marchese
Austin Keefer / Mason McCabe
Shashank Kamdar / Zachary Lessner
Matthew Chen / Johny Mario`);
      const [teamCount, setTeamCount] = useState(16);
      const [teams, setTeams] = useState(Array.from({ length: 16 }, () => ({ p1Name: '', p1Dupr: '', p2Name: '', p2Dupr: '' })));
      const [seedingScores, setSeedingScores] = useState({});
      const [bracketScores, setBracketScores] = useState({});
      const [bracketOverrides, setBracketOverrides] = useState({});
      const [matchupsGenerated, setMatchupsGenerated] = useState(false);
      const [game1Matchups, setGame1Matchups] = useState([]);
      const [game2Matchups, setGame2Matchups] = useState([]);
      const [game3Matchups, setGame3Matchups] = useState([]);
      const [pools, setPools] = useState({});
      const [bracketSwaps, setBracketSwaps] = useState([]);
      const [onCourt, setOnCourt] = useState({});
      const [showOverride, setShowOverride] = useState(false);
      const [dragIndex, setDragIndex] = useState(null);
      const [dragOverIndex, setDragOverIndex] = useState(null);
      const [spectatorMode, setSpectatorMode] = useState(false);
      const [linkCopied, setLinkCopied] = useState(false);

      // Payouts based on team count (prize pool only, not including organizer fee)
      const payouts = {
        12: { first: 420, second: 120, third: 60, total: 600 },
        13: { first: 440, second: 160, third: 60, total: 660 },
        14: { first: 480, second: 160, third: 80, total: 720 },
        15: { first: 500, second: 200, third: 80, total: 780 },
        16: { first: 520, second: 220, third: 100, total: 840 }
      };
      const currentPayouts = payouts[teamCount] || payouts[16];

      // Check URL for shared state on load
      React.useEffect(() => {
        const params = new URLSearchParams(window.location.search);
        const sharedState = params.get('s');
        if (sharedState) {
          try {
            let decoded;
            // Try compressed format first (URL-safe base64 + pako)
            try {
              // Restore URL-safe base64: - to +, _ to /, add padding
              let base64 = sharedState.replace(/-/g, '+').replace(/_/g, '/');
              while (base64.length % 4) base64 += '=';
              const binary = atob(base64);
              const bytes = new Uint8Array(binary.length);
              for (let i = 0; i < binary.length; i++) bytes[i] = binary.charCodeAt(i);
              const decompressed = pako.inflate(bytes, { to: 'string' });
              decoded = JSON.parse(decompressed);
            } catch (compressError) {
              // Fall back to old uncompressed format
              decoded = JSON.parse(atob(sharedState));
            }
            if (decoded.teamCount) setTeamCount(decoded.teamCount);
            if (decoded.teams) setTeams(decoded.teams);
            if (decoded.seedingScores) setSeedingScores(decoded.seedingScores);
            if (decoded.bracketScores) setBracketScores(decoded.bracketScores);
            if (decoded.bracketOverrides) setBracketOverrides(decoded.bracketOverrides);
            if (decoded.game1Matchups) setGame1Matchups(decoded.game1Matchups);
            if (decoded.game2Matchups) setGame2Matchups(decoded.game2Matchups);
            if (decoded.game3Matchups) setGame3Matchups(decoded.game3Matchups);
            if (decoded.pools) setPools(decoded.pools);
            if (decoded.matchupsGenerated) setMatchupsGenerated(decoded.matchupsGenerated);
            if (decoded.onCourt) setOnCourt(decoded.onCourt);
            setSpectatorMode(true);
            setPhase(decoded.phase || 'bracket');
          } catch (e) {
            console.error('Failed to load shared state', e);
          }
        }
      }, []);

      const shareLink = useCallback(() => {
        const state = {
          teamCount,
          teams,
          seedingScores,
          bracketScores,
          bracketOverrides,
          game1Matchups,
          game2Matchups,
          game3Matchups,
          pools,
          matchupsGenerated,
          onCourt,
          phase
        };
        // Compress with pako, then URL-safe base64
        const jsonStr = JSON.stringify(state);
        const compressed = pako.deflate(jsonStr);
        const base64 = btoa(String.fromCharCode.apply(null, compressed));
        // Make URL-safe: replace + with -, / with _, remove padding =
        const urlSafe = base64.replace(/\+/g, '-').replace(/\//g, '_').replace(/=+$/, '');
        const url = `${window.location.origin}${window.location.pathname}?s=${urlSafe}`;
        navigator.clipboard.writeText(url).then(() => {
          setLinkCopied(true);
          setTimeout(() => setLinkCopied(false), 2000);
        });
      }, [teamCount, teams, seedingScores, bracketScores, bracketOverrides, game1Matchups, game2Matchups, game3Matchups, pools, matchupsGenerated, onCourt, phase]);

      const handleDragStart = useCallback((e, index) => {
        setDragIndex(index);
        e.dataTransfer.effectAllowed = 'move';
      }, []);

      const handleDragOver = useCallback((e, index) => {
        e.preventDefault();
        setDragOverIndex(index);
      }, []);

      const handleDrop = useCallback((e, dropIndex) => {
        e.preventDefault();
        if (dragIndex === null || dragIndex === dropIndex) {
          setDragIndex(null);
          setDragOverIndex(null);
          return;
        }
        setTeams(prev => {
          const newTeams = [...prev];
          const [draggedTeam] = newTeams.splice(dragIndex, 1);
          newTeams.splice(dropIndex, 0, draggedTeam);
          return newTeams;
        });
        setDragIndex(null);
        setDragOverIndex(null);
      }, [dragIndex]);

      const getTeamDupr = useCallback((team) => {
        const p1 = parseFloat(team.p1Dupr) || 0;
        const p2 = parseFloat(team.p2Dupr) || 0;
        if (!team.p1Dupr && !team.p2Dupr) return null;
        return (p1 + p2).toFixed(2);
      }, []);

      const getTeamName = useCallback((team) => {
        if (!team.p1Name && !team.p2Name) return '';
        if (!team.p2Name) return team.p1Name;
        if (!team.p1Name) return team.p2Name;
        return `${team.p1Name} / ${team.p2Name}`;
      }, []);

      const teamsValid = teams.every(t => t.p1Name && t.p2Name);

      const parseImportText = useCallback(() => {
        const lines = importText.split('\n').filter(l => l.trim());
        const parsed = lines.map(line => {
          const cleaned = line.replace(/^[\s\*\-\d\.\)\:]+/, '').trim();
          const parts = cleaned.split(/\s*\/\s*/);
          if (parts.length >= 2) {
            return { p1Name: parts[0].trim(), p1Dupr: '', p2Name: parts[1].trim(), p2Dupr: '' };
          }
          return null;
        }).filter(Boolean);

        if (parsed.length >= 12 && parsed.length <= 16) {
          setTeamCount(parsed.length);
          setTeams(parsed);
          setPhase('setup');
        } else {
          alert(`Found ${parsed.length} teams, need 12-16 teams.`);
        }
      }, [importText]);

      const generateRandomMatchups = useCallback(() => {
        const shuffle = (arr) => {
          const a = [...arr];
          for (let i = a.length - 1; i > 0; i--) {
            const j = Math.floor(Math.random() * (i + 1));
            [a[i], a[j]] = [a[j], a[i]];
          }
          return a;
        };

        // Pools of 4 for 12 and 16 teams (snake draft)
        if (teamCount === 12 || teamCount === 16) {
          const numPools = teamCount === 12 ? 3 : 4;
          const poolSize = 4;

          // Snake draft: 1,2,3,4 then 8,7,6,5 then 9,10,11,12...
          const poolAssignments = {};
          const poolTeams = Array.from({ length: numPools }, () => []);

          for (let i = 0; i < teamCount; i++) {
            const row = Math.floor(i / numPools);
            let poolIdx = i % numPools;
            if (row % 2 === 1) poolIdx = numPools - 1 - poolIdx; // Snake
            poolTeams[poolIdx].push(i);
            poolAssignments[i] = poolIdx;
          }

          setPools(poolAssignments);

          // Within each pool: Game 1: 1v3, 2v4; Game 2: 1v2, 3v4; Game 3: 1v4, 2v3
          const g1 = [], g2 = [], g3 = [];
          poolTeams.forEach(pool => {
            g1.push({ t1: pool[0], t2: pool[2] }, { t1: pool[1], t2: pool[3] });
            g2.push({ t1: pool[0], t2: pool[1] }, { t1: pool[2], t2: pool[3] });
            g3.push({ t1: pool[0], t2: pool[3] }, { t1: pool[1], t2: pool[2] });
          });

          setGame1Matchups(shuffle(g1));
          setGame2Matchups(shuffle(g2));
          setGame3Matchups(shuffle(g3));
        } else {
          // 13, 14, 15 teams: 3 random RR games
          // Each team plays 3 unique opponents, balanced as much as possible
          const allTeams = Array.from({ length: teamCount }, (_, i) => i);
          const opponents = {};
          allTeams.forEach(t => opponents[t] = []);

          const g1 = [], g2 = [], g3 = [];

          // For each game round, pair up teams who haven't played each other
          for (let round = 0; round < 3; round++) {
            const available = [...allTeams];
            const roundMatches = [];

            while (available.length >= 2) {
              const t1 = available.shift();
              // Find opponent t1 hasn't played yet
              let t2Idx = available.findIndex(t => !opponents[t1].includes(t));
              if (t2Idx === -1) t2Idx = 0; // Fallback if no unique opponent
              const t2 = available.splice(t2Idx, 1)[0];

              opponents[t1].push(t2);
              opponents[t2].push(t1);
              roundMatches.push({ t1, t2 });
            }

            if (round === 0) setGame1Matchups(shuffle(roundMatches));
            else if (round === 1) setGame2Matchups(shuffle(roundMatches));
            else setGame3Matchups(shuffle(roundMatches));
          }

          // No pools for random matchups
          setPools({});
        }

        setMatchupsGenerated(true);
        setSeedingScores({});
      }, [teamCount]);

      const teamData = useMemo(() => {
        return teams.map((t, i) => ({
          seed: i + 1,
          name: getTeamName(t),
          dupr: getTeamDupr(t)
        }));
      }, [teams, getTeamName, getTeamDupr]);

      const seedingMatches = useMemo(() => {
        const t = teamData;
        if (matchupsGenerated && game1Matchups.length && game2Matchups.length) {
          const result = {
            game1: game1Matchups.map((m, i) => ({
              id: `g1m${i}`,
              t1: t[m.t1],
              t2: t[m.t2],
              court: i + 1
            })),
            game2: game2Matchups.map((m, i) => ({
              id: `g2m${i}`,
              t1: t[m.t1],
              t2: t[m.t2],
              court: i + 1
            })),
            game3: game3Matchups.map((m, i) => ({
              id: `g3m${i}`,
              t1: t[m.t1],
              t2: t[m.t2],
              court: i + 1
            }))
          };
          return result;
        }
        return { game1: [], game2: [], game3: [] };
      }, [teamData, matchupsGenerated, game1Matchups, game2Matchups, game3Matchups]);

      const standings = useMemo(() => {
        const stats = {};
        teamData.forEach(t => {
          stats[t.seed] = { ...t, wins: 0, losses: 0, pf: 0, pa: 0, h2h: {}, pool: pools[t.seed - 1] };
        });

        [...seedingMatches.game1, ...seedingMatches.game2, ...seedingMatches.game3].forEach(m => {
          const score = seedingScores[m.id];
          if (score && score.s1 !== '' && score.s2 !== '' && score.s1 !== undefined && score.s2 !== undefined) {
            const s1 = parseInt(score.s1);
            const s2 = parseInt(score.s2);
            if (!isNaN(s1) && !isNaN(s2)) {
              stats[m.t1.seed].pf += s1;
              stats[m.t1.seed].pa += s2;
              stats[m.t2.seed].pf += s2;
              stats[m.t2.seed].pa += s1;

              if (s1 > s2) {
                stats[m.t1.seed].wins++;
                stats[m.t2.seed].losses++;
                stats[m.t1.seed].h2h[m.t2.seed] = 1;
                stats[m.t2.seed].h2h[m.t1.seed] = -1;
              } else if (s2 > s1) {
                stats[m.t2.seed].wins++;
                stats[m.t1.seed].losses++;
                stats[m.t2.seed].h2h[m.t1.seed] = 1;
                stats[m.t1.seed].h2h[m.t2.seed] = -1;
              }
            }
          }
        });

        return Object.values(stats).sort((a, b) => {
          if (b.wins !== a.wins) return b.wins - a.wins;
          const h2h = a.h2h[b.seed] || 0;
          if (h2h !== 0) return -h2h;
          return (b.pf - b.pa) - (a.pf - a.pa);
        });
      }, [teamData, seedingScores, seedingMatches]);

      const bracketTeams = useMemo(() => {
        if (standings.length < teamCount) return { winners: [], losers: [], swaps: [] };

        // Split into winners and losers
        const winnersCount = Math.ceil(teamCount / 2);
        const losersCount = teamCount - winnersCount;
        let winners = standings.slice(0, winnersCount);
        let losers = standings.slice(winnersCount);

        const swaps = [];

        // Apply no-repeat constraint: no same-pool matchups in round 1
        // Standard matchups by seed: 1v8, 4v5, 2v7, 3v6 (for 8 teams)
        const applyNoRepeat = (teams, bracketName) => {
          if (teams.length < 2) return teams;
          const result = [...teams];

          // Get matchups based on team count
          const getMatchups = (n) => {
            if (n <= 4) return [[0, n-1], [1, n-2]].filter(m => m[1] >= 0 && m[0] < m[1]);
            if (n <= 6) return [[0, n-1], [1, n-2], [2, n-3]].filter(m => m[1] >= 0 && m[0] < m[1]);
            if (n <= 8) return [[0, 7], [3, 4], [1, 6], [2, 5]].filter(m => m[1] < n);
            return [[0, 7], [3, 4], [1, 6], [2, 5]];
          };

          const matchups = getMatchups(result.length);

          // Check each matchup for same-pool conflict
          for (const [i, j] of matchups) {
            if (i >= result.length || j >= result.length) continue;
            const t1 = result[i];
            const t2 = result[j];

            // Check if same pool (only if pools are assigned)
            if (t1.pool !== undefined && t2.pool !== undefined && t1.pool === t2.pool) {
              // Find someone to swap with (not seed 1, and not from same pool as opponent)
              for (let k = j + 1; k < result.length; k++) {
                if (result[k].pool !== t1.pool) {
                  // Also check that swapping doesn't create a new conflict
                  const otherMatchup = matchups.find(m => m.includes(k));
                  if (otherMatchup) {
                    const otherIdx = otherMatchup[0] === k ? otherMatchup[1] : otherMatchup[0];
                    if (otherIdx < result.length && result[otherIdx].pool === t2.pool) continue; // Would create new conflict
                  }

                  swaps.push(`${bracketName}: Swapped seed ${j + 1} (${t2.name}) with seed ${k + 1} (${result[k].name}) to avoid pool rematch`);
                  [result[j], result[k]] = [result[k], result[j]];
                  break;
                }
              }
            }
          }
          return result;
        };

        winners = applyNoRepeat(winners, 'Winners');
        losers = applyNoRepeat(losers, 'Losers');

        setBracketSwaps(swaps);

        return { winners, losers, swaps };
      }, [standings, teamCount]);

      const generateFakeSeedingScores = useCallback(() => {
        const fakeScores = {};
        [...seedingMatches.game1, ...seedingMatches.game2, ...seedingMatches.game3].forEach(m => {
          const seedDiff = m.t2.seed - m.t1.seed; // positive = t1 is better seed
          const t1WinProb = 0.5 + (seedDiff * 0.03); // 3% advantage per seed difference
          const t1Wins = Math.random() < t1WinProb;
          const winScore = 11;
          const loseScore = Math.floor(Math.random() * 8) + 2; // 2-9
          fakeScores[m.id] = {
            s1: t1Wins ? winScore : loseScore,
            s2: t1Wins ? loseScore : winScore
          };
        });
        setSeedingScores(fakeScores);
      }, [seedingMatches]);

      const generateFakeBracketScores = useCallback(() => {
        const fakeScores = {};

        // We need to simulate in order since later matches depend on earlier results
        const getWinner = (id) => {
          const s = fakeScores[id];
          if (!s) return null;
          // Handle Bo3 with games array
          if (s.games) {
            let t1Wins = 0, t2Wins = 0;
            s.games.forEach(g => { if (g.s1 > g.s2) t1Wins++; else t2Wins++; });
            return t1Wins > t2Wins ? s.t1 : s.t2;
          }
          return parseInt(s.s1) > parseInt(s.s2) ? s.t1 : s.t2;
        };
        const getLoser = (id) => {
          const s = fakeScores[id];
          if (!s) return null;
          // Handle Bo3 with games array
          if (s.games) {
            let t1Wins = 0, t2Wins = 0;
            s.games.forEach(g => { if (g.s1 > g.s2) t1Wins++; else t2Wins++; });
            return t1Wins > t2Wins ? s.t2 : s.t1;
          }
          return parseInt(s.s1) > parseInt(s.s2) ? s.t2 : s.t1;
        };

        const w = bracketTeams.winners;
        const l = bracketTeams.losers;
        if (w.length < 8) return;

        const simulateMatch = (t1, t2) => {
          if (!t1 || !t2) return null;
          const seedDiff = t2.seed - t1.seed;
          const t1WinProb = 0.5 + (seedDiff * 0.025);
          const t1Wins = Math.random() < t1WinProb;
          const winScore = 15;
          const loseScore = Math.floor(Math.random() * 10) + 4; // 4-13
          return { t1, t2, s1: t1Wins ? winScore : loseScore, s2: t1Wins ? loseScore : winScore };
        };

        // Bo3 matches store individual game scores to 11
        const simulateBo3Match = (t1, t2) => {
          if (!t1 || !t2) return null;
          const seedDiff = t2.seed - t1.seed;
          const t1WinProb = 0.5 + (seedDiff * 0.025);

          const games = [];
          let t1Wins = 0, t2Wins = 0;

          while (t1Wins < 2 && t2Wins < 2) {
            const t1WinsGame = Math.random() < t1WinProb;
            const winScore = 11;
            const loseScore = Math.floor(Math.random() * 8) + 2; // 2-9
            games.push({
              s1: t1WinsGame ? winScore : loseScore,
              s2: t1WinsGame ? loseScore : winScore
            });
            if (t1WinsGame) t1Wins++; else t2Wins++;
          }

          return { t1, t2, games };
        };

        // Winners QF
        fakeScores.wqf1 = simulateMatch(w[0], w[7]);
        fakeScores.wqf2 = simulateMatch(w[3], w[4]);
        fakeScores.wqf3 = simulateMatch(w[1], w[6]);
        fakeScores.wqf4 = simulateMatch(w[2], w[5]);

        // Losers R1
        fakeScores.lr1m1 = simulateMatch(l[0], l[7]);
        fakeScores.lr1m2 = simulateMatch(l[3], l[4]);
        fakeScores.lr1m3 = simulateMatch(l[1], l[6]);
        fakeScores.lr1m4 = simulateMatch(l[2], l[5]);

        // Winners SF
        fakeScores.wsf1 = simulateMatch(getWinner('wqf1'), getWinner('wqf2'));
        fakeScores.wsf2 = simulateMatch(getWinner('wqf3'), getWinner('wqf4'));

        // Losers R2
        fakeScores.lr2m1 = simulateMatch(getWinner('lr1m1'), getLoser('wqf1'));
        fakeScores.lr2m2 = simulateMatch(getWinner('lr1m2'), getLoser('wqf2'));
        fakeScores.lr2m3 = simulateMatch(getWinner('lr1m3'), getLoser('wqf3'));
        fakeScores.lr2m4 = simulateMatch(getWinner('lr1m4'), getLoser('wqf4'));

        // Losers R3
        fakeScores.lr3m1 = simulateMatch(getWinner('lr2m1'), getWinner('lr2m2'));
        fakeScores.lr3m2 = simulateMatch(getWinner('lr2m3'), getWinner('lr2m4'));

        // Winners Final (Bo3)
        fakeScores.wf = simulateBo3Match(getWinner('wsf1'), getWinner('wsf2'));

        // Losers R4
        fakeScores.lr4m1 = simulateMatch(getWinner('lr3m1'), getLoser('wsf1'));
        fakeScores.lr4m2 = simulateMatch(getWinner('lr3m2'), getLoser('wsf2'));

        // Losers Semi
        fakeScores.lsf = simulateMatch(getWinner('lr4m1'), getWinner('lr4m2'));

        // Losers Final
        fakeScores.lf = simulateMatch(getWinner('lsf'), getLoser('wf'));

        // Grand Final (Bo3)
        fakeScores.gf = simulateBo3Match(getWinner('wf'), getWinner('lf'));

        setBracketScores(fakeScores);
      }, [bracketTeams]);

      const getBracketMatchTeam = useCallback((id) => {
        if (bracketOverrides[id] && bracketOverrides[id].winner) {
          return bracketOverrides[id].winner;
        }
        const score = bracketScores[id];
        if (!score) return null;

        // Handle Bo3 with games array
        if (score.games && score.games.length > 0) {
          let t1Wins = 0, t2Wins = 0;
          score.games.forEach(g => {
            if (parseInt(g.s1) > parseInt(g.s2)) t1Wins++;
            else t2Wins++;
          });
          if (t1Wins >= 2) return score.t1;
          if (t2Wins >= 2) return score.t2;
          return null;
        }

        // Regular match
        if (score.s1 === '' || score.s2 === '' || score.s1 === undefined || score.s2 === undefined) return null;
        return parseInt(score.s1) > parseInt(score.s2) ? score.t1 : score.t2;
      }, [bracketScores, bracketOverrides]);

      const getBracketMatchLoser = useCallback((id) => {
        if (bracketOverrides[id] && bracketOverrides[id].loser) {
          return bracketOverrides[id].loser;
        }
        const score = bracketScores[id];
        if (!score) return null;

        // Handle Bo3 with games array
        if (score.games && score.games.length > 0) {
          let t1Wins = 0, t2Wins = 0;
          score.games.forEach(g => {
            if (parseInt(g.s1) > parseInt(g.s2)) t1Wins++;
            else t2Wins++;
          });
          if (t1Wins >= 2) return score.t2;
          if (t2Wins >= 2) return score.t1;
          return null;
        }

        // Regular match
        if (score.s1 === '' || score.s2 === '' || score.s1 === undefined || score.s2 === undefined) return null;
        return parseInt(score.s1) > parseInt(score.s2) ? score.t2 : score.t1;
      }, [bracketScores, bracketOverrides]);

      const bracketMatches = useMemo(() => {
        const w = bracketTeams.winners || [];
        const l = bracketTeams.losers || [];
        if (w.length < 6 || teamCount < 12) return {}; // Need at least 6 winners for a meaningful bracket

        // For now, support 16-team bracket (8v8) fully
        // TODO: Add byes for 12-15 teams
        if (w.length < 8 || l.length < 8) return {};

        return {
          wqf1: { id: 'wqf1', t1: w[0], t2: w[7], round: 'W-QF', court: 1 },
          wqf2: { id: 'wqf2', t1: w[3], t2: w[4], round: 'W-QF', court: 2 },
          wqf3: { id: 'wqf3', t1: w[1], t2: w[6], round: 'W-QF', court: 3 },
          wqf4: { id: 'wqf4', t1: w[2], t2: w[5], round: 'W-QF', court: 4 },
          wsf1: { id: 'wsf1', t1: getBracketMatchTeam('wqf1'), t2: getBracketMatchTeam('wqf2'), round: 'W-SF' },
          wsf2: { id: 'wsf2', t1: getBracketMatchTeam('wqf3'), t2: getBracketMatchTeam('wqf4'), round: 'W-SF' },
          wf: { id: 'wf', t1: getBracketMatchTeam('wsf1'), t2: getBracketMatchTeam('wsf2'), round: 'W-Final', bo3: true },
          lr1m1: { id: 'lr1m1', t1: l[0], t2: l[7], round: 'L-R1', court: 5 },
          lr1m2: { id: 'lr1m2', t1: l[3], t2: l[4], round: 'L-R1', court: 6 },
          lr1m3: { id: 'lr1m3', t1: l[1], t2: l[6], round: 'L-R1', court: 7 },
          lr1m4: { id: 'lr1m4', t1: l[2], t2: l[5], round: 'L-R1', court: 8 },
          lr2m1: { id: 'lr2m1', t1: getBracketMatchTeam('lr1m1'), t2: getBracketMatchLoser('wqf1'), round: 'L-R2' },
          lr2m2: { id: 'lr2m2', t1: getBracketMatchTeam('lr1m2'), t2: getBracketMatchLoser('wqf2'), round: 'L-R2' },
          lr2m3: { id: 'lr2m3', t1: getBracketMatchTeam('lr1m3'), t2: getBracketMatchLoser('wqf3'), round: 'L-R2' },
          lr2m4: { id: 'lr2m4', t1: getBracketMatchTeam('lr1m4'), t2: getBracketMatchLoser('wqf4'), round: 'L-R2' },
          lr3m1: { id: 'lr3m1', t1: getBracketMatchTeam('lr2m1'), t2: getBracketMatchTeam('lr2m2'), round: 'L-R3' },
          lr3m2: { id: 'lr3m2', t1: getBracketMatchTeam('lr2m3'), t2: getBracketMatchTeam('lr2m4'), round: 'L-R3' },
          lr4m1: { id: 'lr4m1', t1: getBracketMatchTeam('lr3m1'), t2: getBracketMatchLoser('wsf1'), round: 'L-R4' },
          lr4m2: { id: 'lr4m2', t1: getBracketMatchTeam('lr3m2'), t2: getBracketMatchLoser('wsf2'), round: 'L-R4' },
          lsf: { id: 'lsf', t1: getBracketMatchTeam('lr4m1'), t2: getBracketMatchTeam('lr4m2'), round: 'L-Semi' },
          lf: { id: 'lf', t1: getBracketMatchTeam('lsf'), t2: getBracketMatchLoser('wf'), round: 'L-Final' },
          gf: { id: 'gf', t1: getBracketMatchTeam('wf'), t2: getBracketMatchTeam('lf'), round: 'Grand Final', bo3: true }
        };
      }, [bracketTeams, getBracketMatchTeam, getBracketMatchLoser]);

      const handleTeamChange = useCallback((index, field, value) => {
        setTeams(prev => prev.map((t, i) => i === index ? { ...t, [field]: value } : t));
      }, []);

      const handleSeedingScore = useCallback((id, field, value) => {
        setSeedingScores(prev => ({
          ...prev,
          [id]: { ...prev[id], [field]: value }
        }));
      }, []);

      const handleBracketScore = useCallback((matchId, t1, t2, field, value) => {
        setBracketScores(prev => ({
          ...prev,
          [matchId]: {
            t1,
            t2,
            s1: field === 's1' ? value : (prev[matchId]?.s1 || ''),
            s2: field === 's2' ? value : (prev[matchId]?.s2 || '')
          }
        }));
      }, []);

      const handleBracketOverride = useCallback((id, winner, loser) => {
        setBracketOverrides(prev => ({ ...prev, [id]: { winner, loser } }));
      }, []);

      const clearBracketOverride = useCallback((id) => {
        setBracketOverrides(prev => {
          const newOverrides = { ...prev };
          delete newOverrides[id];
          return newOverrides;
        });
      }, []);

      const toggleOnCourt = useCallback((id) => {
        setOnCourt(prev => ({ ...prev, [id]: !prev[id] }));
      }, []);

      const allSeedingComplete = useMemo(() => {
        const allMatches = [...seedingMatches.game1, ...seedingMatches.game2, ...seedingMatches.game3];
        if (!allMatches.length) return false;
        return allMatches.every(m => {
          const s = seedingScores[m.id];
          return s && s.s1 !== '' && s.s2 !== '' && s.s1 !== undefined && s.s2 !== undefined;
        });
      }, [seedingMatches, seedingScores]);

      const onCourtMatches = useMemo(() => {
        const matches = [];
        Object.keys(onCourt).forEach(id => {
          if (onCourt[id]) {
            const seedMatch = [...seedingMatches.game1, ...seedingMatches.game2, ...seedingMatches.game3].find(m => m.id === id);
            if (seedMatch) {
              matches.push({ ...seedMatch, type: 'seeding' });
              return;
            }
            if (bracketMatches[id]) {
              matches.push({ ...bracketMatches[id], type: 'bracket' });
            }
          }
        });
        return matches;
      }, [onCourt, seedingMatches, bracketMatches]);

      const nextUpMatches = useMemo(() => {
        const next = [];
        if (phase === 'roundrobin') {
          [...seedingMatches.game1, ...seedingMatches.game2].forEach(m => {
            const s = seedingScores[m.id];
            const complete = s && s.s1 !== '' && s.s2 !== '' && s.s1 !== undefined && s.s2 !== undefined;
            if (!complete && !onCourt[m.id]) {
              next.push({ ...m, type: 'seeding' });
            }
          });
        }
        if (phase === 'bracket') {
          const order = ['wqf1','wqf2','wqf3','wqf4','lr1m1','lr1m2','lr1m3','lr1m4','wsf1','wsf2','lr2m1','lr2m2','lr2m3','lr2m4','lr3m1','lr3m2','lr4m1','lr4m2','lsf','wf','lf','gf'];
          order.forEach(id => {
            const m = bracketMatches[id];
            const s = bracketScores[id];
            const o = bracketOverrides[id];
            const complete = o || (s && s.s1 !== '' && s.s2 !== '' && s.s1 !== undefined && s.s2 !== undefined);
            if (m && m.t1 && m.t2 && !complete && !onCourt[id]) {
              next.push({ ...m, type: 'bracket' });
            }
          });
        }
        return next;
      }, [phase, seedingMatches, seedingScores, bracketMatches, bracketScores, bracketOverrides, onCourt]);

      const saveProgress = useCallback(() => {
        const data = {
          teams,
          seedingScores,
          bracketScores,
          bracketOverrides,
          matchupsGenerated,
          game1Matchups,
          game2Matchups,
          onCourt
        };
        const blob = new Blob([JSON.stringify(data, null, 2)], { type: 'application/json' });
        const url = URL.createObjectURL(blob);
        const a = document.createElement('a');
        a.href = url;
        a.download = `moneyballs-${new Date().toISOString().split('T')[0]}.json`;
        a.click();
        URL.revokeObjectURL(url);
      }, [teams, seedingScores, bracketScores, bracketOverrides, matchupsGenerated, game1Matchups, game2Matchups, onCourt]);

      const loadProgress = useCallback((e) => {
        const file = e.target.files[0];
        if (!file) return;
        const reader = new FileReader();
        reader.onload = (event) => {
          try {
            const data = JSON.parse(event.target.result);
            if (data.teams) setTeams(data.teams);
            if (data.seedingScores) setSeedingScores(data.seedingScores);
            if (data.bracketScores) setBracketScores(data.bracketScores);
            if (data.bracketOverrides) setBracketOverrides(data.bracketOverrides);
            if (data.game1Matchups) setGame1Matchups(data.game1Matchups);
            if (data.game2Matchups) setGame2Matchups(data.game2Matchups);
            if (data.matchupsGenerated) setMatchupsGenerated(data.matchupsGenerated);
            if (data.onCourt) setOnCourt(data.onCourt);
            setPhase('setup');
          } catch (err) {
            alert('Invalid file');
          }
        };
        reader.readAsText(file);
      }, []);

      const downloadResults = useCallback(() => {
        const winner = getBracketMatchTeam('gf');
        const second = getBracketMatchLoser('gf');
        const third = getBracketMatchLoser('lf');
        const date = new Date().toLocaleDateString('en-US', { year: 'numeric', month: 'long', day: 'numeric' });

        let results = `JORDAN'S MONEYBALLS - ${date}\n`;
        results += `==================================================\n\n`;
        results += `üèÜ FINAL STANDINGS (BRACKET)\n`;
        results += `------------------------------\n`;
        results += `ü•á 1st ($${currentPayouts.first}): ${winner ? winner.name : 'TBD'}\n`;
        results += `ü•à 2nd ($${currentPayouts.second}): ${second ? second.name : 'TBD'}\n`;
        results += `ü•â 3rd ($${currentPayouts.third}): ${third ? third.name : 'TBD'}\n\n`;

        results += `TEAMS (INITIAL SEEDING)\n`;
        results += `------------------------------\n`;
        teams.forEach((t, i) => {
          results += `${i + 1}. ${getTeamName(t)}${getTeamDupr(t) ? ` (${getTeamDupr(t)})` : ''}\n`;
        });

        results += `\n==================================================\n`;
        results += `ROUND ROBIN SCORES\n`;
        results += `==================================================\n\n`;

        results += `GAME 1\n`;
        results += `------------------------------\n`;
        seedingMatches.game1.forEach(m => {
          const score = seedingScores[m.id];
          if (score && score.s1 !== undefined && score.s2 !== undefined) {
            const s1Won = parseInt(score.s1) > parseInt(score.s2);
            results += `${s1Won ? '‚úì' : ' '} ${m.t1.name} ${score.s1}-${score.s2} ${m.t2.name} ${!s1Won ? '‚úì' : ''}\n`;
          }
        });

        results += `\nGAME 2\n`;
        results += `------------------------------\n`;
        seedingMatches.game2.forEach(m => {
          const score = seedingScores[m.id];
          if (score && score.s1 !== undefined && score.s2 !== undefined) {
            const s1Won = parseInt(score.s1) > parseInt(score.s2);
            results += `${s1Won ? '‚úì' : ' '} ${m.t1.name} ${score.s1}-${score.s2} ${m.t2.name} ${!s1Won ? '‚úì' : ''}\n`;
          }
        });

        if (seedingMatches.game3.length > 0) {
          results += `\nGAME 3\n`;
          results += `------------------------------\n`;
          seedingMatches.game3.forEach(m => {
            const score = seedingScores[m.id];
            if (score && score.s1 !== undefined && score.s2 !== undefined) {
              const s1Won = parseInt(score.s1) > parseInt(score.s2);
              results += `${s1Won ? '‚úì' : ' '} ${m.t1.name} ${score.s1}-${score.s2} ${m.t2.name} ${!s1Won ? '‚úì' : ''}\n`;
            }
          });
        }

        results += `\nROUND ROBIN STANDINGS\n`;
        results += `------------------------------\n`;
        const winnersCount = Math.ceil(teamCount / 2);
        standings.forEach((t, i) => {
          const bracket = i < winnersCount ? '‚Üí Winners' : '‚Üí Losers';
          results += `${i + 1}. ${t.name} ${t.wins}-${t.losses} (${t.pf - t.pa >= 0 ? '+' : ''}${t.pf - t.pa}) ${bracket}\n`;
        });

        results += `\n==================================================\n`;
        results += `BRACKET SCORES\n`;
        results += `==================================================\n\n`;

        const formatBracketMatch = (id, label) => {
          const match = bracketMatches[id];
          const score = bracketScores[id];
          if (!match || !match.t1 || !match.t2) return '';
          if (!score) return `${label}: ${match.t1.name} vs ${match.t2.name} - Not played\n`;

          if (match.bo3 && score.games && score.games.length > 0) {
            const gameScores = score.games.map(g => `${g.s1}-${g.s2}`).join(', ');
            const t1Wins = score.games.filter(g => g.s1 > g.s2).length;
            const t2Wins = score.games.filter(g => g.s2 > g.s1).length;
            const winner = t1Wins > t2Wins ? match.t1.name : match.t2.name;
            return `${label}: ${match.t1.name} vs ${match.t2.name} (${gameScores}) ‚Üí ${winner}\n`;
          } else if (score.s1 !== undefined && score.s2 !== undefined) {
            const winner = parseInt(score.s1) > parseInt(score.s2) ? match.t1.name : match.t2.name;
            return `${label}: ${match.t1.name} ${score.s1}-${score.s2} ${match.t2.name} ‚Üí ${winner}\n`;
          }
          return '';
        };

        results += `WINNERS BRACKET\n`;
        results += `------------------------------\n`;
        ['wqf1', 'wqf2', 'wqf3', 'wqf4'].forEach(id => results += formatBracketMatch(id, 'W-QF'));
        ['wsf1', 'wsf2'].forEach(id => results += formatBracketMatch(id, 'W-SF'));
        results += formatBracketMatch('wf', 'W-Final (Bo3)');

        results += `\nLOSERS BRACKET\n`;
        results += `------------------------------\n`;
        ['lr1m1', 'lr1m2', 'lr1m3', 'lr1m4'].forEach(id => results += formatBracketMatch(id, 'L-R1'));
        ['lr2m1', 'lr2m2', 'lr2m3', 'lr2m4'].forEach(id => results += formatBracketMatch(id, 'L-R2'));
        ['lr3m1', 'lr3m2'].forEach(id => results += formatBracketMatch(id, 'L-R3'));
        ['lr4m1', 'lr4m2'].forEach(id => results += formatBracketMatch(id, 'L-R4'));
        results += formatBracketMatch('lsf', 'L-Semi');
        results += formatBracketMatch('lf', 'L-Final');

        results += `\nGRAND FINAL (Bo3)\n`;
        results += `------------------------------\n`;
        results += formatBracketMatch('gf', 'Grand Final');

        const blob = new Blob([results], { type: 'text/plain' });
        const url = URL.createObjectURL(blob);
        const a = document.createElement('a');
        a.href = url;
        a.download = `moneyballs-results-${new Date().toISOString().split('T')[0]}.txt`;
        a.click();
        URL.revokeObjectURL(url);
      }, [teams, standings, seedingMatches, seedingScores, bracketMatches, bracketScores, getTeamName, getTeamDupr, getBracketMatchTeam, getBracketMatchLoser]);

      const gfWinner = getBracketMatchTeam('gf');

      return (
        <div className="bg-gray-900 text-white p-4 min-h-screen">
          <h1 className="text-2xl font-bold text-center mb-1">üèì Jordan's Moneyballs</h1>
          <p className="text-center text-gray-400 text-sm mb-2">$30/player ‚Ä¢ ${currentPayouts.first}/${currentPayouts.second}/${currentPayouts.third}</p>

          {spectatorMode && (
            <div className="bg-blue-900 border border-blue-500 text-blue-200 text-center py-2 px-4 rounded mb-3 max-w-md mx-auto">
              üëÅÔ∏è Spectator Mode - View Only
            </div>
          )}

          {!spectatorMode && (
            <div className="flex justify-center gap-2 mb-2">
              <button onClick={saveProgress} className="text-xs bg-gray-700 px-2 py-1 rounded hover:bg-gray-600">üíæ Save</button>
              <label className="text-xs bg-gray-700 px-2 py-1 rounded hover:bg-gray-600 cursor-pointer">
                üìÇ Load
                <input type="file" accept=".json" className="hidden" onChange={loadProgress} />
              </label>
              <button onClick={shareLink} className={`text-xs px-2 py-1 rounded ${linkCopied ? 'bg-green-600' : 'bg-blue-600 hover:bg-blue-500'}`}>
                {linkCopied ? '‚úì Copied!' : 'üîó Share Link'}
              </button>
            </div>
          )}

          <div className="flex justify-center gap-2 mb-4 flex-wrap">
            <button onClick={() => setPhase('import')} className={`px-3 py-1 rounded text-sm ${phase === 'import' ? 'bg-orange-600' : 'bg-gray-700'}`}>Import</button>
            <button onClick={() => setPhase('setup')} className={`px-3 py-1 rounded text-sm ${phase === 'setup' ? 'bg-purple-600' : 'bg-gray-700'}`} disabled={!teamsValid}>Setup</button>
            <button onClick={() => setPhase('roundrobin')} className={`px-3 py-1 rounded text-sm ${phase === 'roundrobin' ? 'bg-blue-600' : 'bg-gray-700'}`} disabled={!matchupsGenerated}>Round Robin</button>
            <button onClick={() => setPhase('standings')} className={`px-3 py-1 rounded text-sm ${phase === 'standings' ? 'bg-cyan-600' : 'bg-gray-700'}`} disabled={!matchupsGenerated}>Standings</button>
            <button onClick={() => setPhase('bracket')} className={`px-3 py-1 rounded text-sm ${phase === 'bracket' ? 'bg-green-600' : 'bg-gray-700'}`} disabled={!allSeedingComplete}>Bracket</button>
            <button onClick={() => setPhase('results')} className={`px-3 py-1 rounded text-sm ${phase === 'results' ? 'bg-yellow-600' : 'bg-gray-700'}`} disabled={!gfWinner}>Results</button>
          </div>

          {phase === 'import' && (
            <div className="max-w-2xl mx-auto">
              <h2 className="text-xl font-semibold mb-4 text-center">Import Teams (Ranked 1-16)</h2>
              <textarea
                className="w-full h-72 bg-gray-800 border border-gray-600 rounded p-3 text-sm font-mono"
                placeholder="* Player 1 / Player 2&#10;* Player 3 / Player 4&#10;...etc (16 teams)"
                value={importText}
                onChange={(e) => setImportText(e.target.value)}
              />
              <button onClick={parseImportText} className="w-full mt-4 bg-orange-600 hover:bg-orange-500 py-2 rounded font-semibold">
                Import Teams (12-16) ‚Üí
              </button>
            </div>
          )}

          {phase === 'setup' && (
            <div className="max-w-4xl mx-auto">
              <h2 className="text-xl font-semibold mb-2 text-center">Teams & Pods</h2>
              <p className="text-gray-400 text-xs text-center mb-4">Drag teams to reorder seeding</p>
              <div className="grid md:grid-cols-2 gap-4">
                <div>
                  <h3 className="text-yellow-400 font-semibold mb-2">Pod A (1-4)</h3>
                  {[0, 1, 2, 3].map(i => (
                    <TeamInput
                      key={`team-${i}`}
                      index={i}
                      color="text-yellow-400"
                      team={teams[i]}
                      dupr={getTeamDupr(teams[i])}
                      onChange={(field, value) => handleTeamChange(i, field, value)}
                      onDragStart={handleDragStart}
                      onDragOver={handleDragOver}
                      onDrop={handleDrop}
                      isDragging={dragIndex === i}
                      isDragOver={dragOverIndex === i}
                    />
                  ))}
                  <h3 className="text-blue-400 font-semibold mb-2 mt-4">Pod B (5-8)</h3>
                  {[4, 5, 6, 7].map(i => (
                    <TeamInput
                      key={`team-${i}`}
                      index={i}
                      color="text-blue-400"
                      team={teams[i]}
                      dupr={getTeamDupr(teams[i])}
                      onChange={(field, value) => handleTeamChange(i, field, value)}
                      onDragStart={handleDragStart}
                      onDragOver={handleDragOver}
                      onDrop={handleDrop}
                      isDragging={dragIndex === i}
                      isDragOver={dragOverIndex === i}
                    />
                  ))}
                </div>
                <div>
                  <h3 className="text-green-400 font-semibold mb-2">Pod C (9-12)</h3>
                  {[8, 9, 10, 11].map(i => (
                    <TeamInput
                      key={`team-${i}`}
                      index={i}
                      color="text-green-400"
                      team={teams[i]}
                      dupr={getTeamDupr(teams[i])}
                      onChange={(field, value) => handleTeamChange(i, field, value)}
                      onDragStart={handleDragStart}
                      onDragOver={handleDragOver}
                      onDrop={handleDrop}
                      isDragging={dragIndex === i}
                      isDragOver={dragOverIndex === i}
                    />
                  ))}
                  <h3 className="text-red-400 font-semibold mb-2 mt-4">Pod D (13-16)</h3>
                  {[12, 13, 14, 15].map(i => (
                    <TeamInput
                      key={`team-${i}`}
                      index={i}
                      color="text-red-400"
                      team={teams[i]}
                      dupr={getTeamDupr(teams[i])}
                      onChange={(field, value) => handleTeamChange(i, field, value)}
                      onDragStart={handleDragStart}
                      onDragOver={handleDragOver}
                      onDrop={handleDrop}
                      isDragging={dragIndex === i}
                      isDragOver={dragOverIndex === i}
                    />
                  ))}
                </div>
              </div>
              {teamsValid && (
                <div className="mt-4">
                  <button onClick={generateRandomMatchups} className="w-full bg-yellow-600 hover:bg-yellow-500 py-2 rounded font-semibold mb-2">
                    üé≤ Randomize Matchups
                  </button>
                  {matchupsGenerated && (
                    <button onClick={() => setPhase('roundrobin')} className="w-full bg-blue-600 py-2 rounded font-semibold">
                      Start Round Robin ‚Üí
                    </button>
                  )}
                </div>
              )}
            </div>
          )}

          {phase === 'roundrobin' && (
            <div className="max-w-6xl mx-auto">
              <div className="flex justify-between items-center mb-2">
                <h2 className="text-xl font-semibold">Round Robin ({teamCount} teams, {Object.keys(pools).length > 0 ? `${teamCount === 12 ? '3' : '4'} pools` : '3 random games'})</h2>
                {!spectatorMode && <button onClick={generateFakeSeedingScores} className="text-xs bg-purple-700 hover:bg-purple-600 px-2 py-1 rounded">üé≤ Test Scores</button>}
              </div>
              {!spectatorMode && <CourtStatus onCourtMatches={onCourtMatches} nextUpMatches={nextUpMatches} onToggleCourt={toggleOnCourt} />}

              {Object.keys(pools).length > 0 && (
                <div className="mb-4 bg-gray-800 rounded p-3">
                  <div className="text-sm font-semibold mb-2">Pool Assignments (Snake Draft)</div>
                  <div className="grid grid-cols-3 md:grid-cols-4 gap-2 text-xs">
                    {Array.from({ length: teamCount === 12 ? 3 : 4 }, (_, poolIdx) => (
                      <div key={poolIdx} className="bg-gray-700 rounded p-2">
                        <div className="font-semibold text-center mb-1" style={{ color: ['#facc15', '#60a5fa', '#4ade80', '#f87171'][poolIdx] }}>
                          Pool {String.fromCharCode(65 + poolIdx)}
                        </div>
                        {Object.entries(pools).filter(([_, p]) => p === poolIdx).map(([teamIdx]) => (
                          <div key={teamIdx} className="truncate text-gray-300">{parseInt(teamIdx) + 1}. {teams[teamIdx]?.p1Name?.split(' ')[0]}</div>
                        ))}
                      </div>
                    ))}
                  </div>
                </div>
              )}

              <div className="grid md:grid-cols-3 gap-4">
                <div>
                  <h3 className="text-blue-400 font-semibold mb-2 text-center">Game 1</h3>
                  <div className="space-y-2">
                    {seedingMatches.game1.map(m => (
                      <SeedingMatch
                        key={m.id}
                        match={m}
                        score={seedingScores[m.id] || {}}
                        isOnCourt={onCourt[m.id]}
                        onScoreChange={(field, value) => handleSeedingScore(m.id, field, value)}
                        onToggleCourt={() => toggleOnCourt(m.id)}
                        readOnly={spectatorMode}
                      />
                    ))}
                  </div>
                </div>
                <div>
                  <h3 className="text-green-400 font-semibold mb-2 text-center">Game 2</h3>
                  <div className="space-y-2">
                    {seedingMatches.game2.map(m => (
                      <SeedingMatch
                        key={m.id}
                        match={m}
                        score={seedingScores[m.id] || {}}
                        isOnCourt={onCourt[m.id]}
                        onScoreChange={(field, value) => handleSeedingScore(m.id, field, value)}
                        onToggleCourt={() => toggleOnCourt(m.id)}
                        readOnly={spectatorMode}
                      />
                    ))}
                  </div>
                </div>
                <div>
                  <h3 className="text-yellow-400 font-semibold mb-2 text-center">Game 3</h3>
                  <div className="space-y-2">
                    {seedingMatches.game3.map(m => (
                      <SeedingMatch
                        key={m.id}
                        match={m}
                        score={seedingScores[m.id] || {}}
                        isOnCourt={onCourt[m.id]}
                        onScoreChange={(field, value) => handleSeedingScore(m.id, field, value)}
                        onToggleCourt={() => toggleOnCourt(m.id)}
                        readOnly={spectatorMode}
                      />
                    ))}
                  </div>
                </div>
              </div>
              {allSeedingComplete && (
                <button onClick={() => setPhase('bracket')} className="w-full mt-4 bg-green-600 py-2 rounded font-semibold">
                  Start Bracket ‚Üí
                </button>
              )}
            </div>
          )}

          {phase === 'standings' && (
            <div className="max-w-2xl mx-auto">
              <h2 className="text-xl font-semibold mb-4 text-center">Live Standings</h2>
              <div className="bg-gray-800 rounded p-3">
                <div className="text-xs text-gray-500 flex px-2 mb-2">
                  <span className="w-8">Rk</span>
                  {Object.keys(pools).length > 0 && <span className="w-10">Pool</span>}
                  <span className="flex-1">Team</span>
                  <span className="w-12 text-center">W-L</span>
                  <span className="w-12 text-center">PF</span>
                  <span className="w-12 text-center">PA</span>
                  <span className="w-12 text-right">PD</span>
                </div>
                {standings.map((t, i) => {
                  const winnersCount = Math.ceil(teamCount / 2);
                  const isWinners = i < winnersCount;
                  const poolColors = ['text-yellow-400', 'text-blue-400', 'text-green-400', 'text-red-400'];
                  return (
                    <div key={t.seed} className={`flex items-center text-sm py-2 px-2 rounded mb-1 ${isWinners ? 'bg-blue-900/30' : 'bg-red-900/30'}`}>
                      <span className={`w-8 font-bold ${isWinners ? 'text-blue-400' : 'text-red-400'}`}>{i + 1}</span>
                      {Object.keys(pools).length > 0 && (
                        <span className={`w-10 text-xs ${poolColors[t.pool] || 'text-gray-400'}`}>
                          {t.pool !== undefined ? String.fromCharCode(65 + t.pool) : '-'}
                        </span>
                      )}
                      <span className="flex-1 truncate">{t.name}</span>
                      <span className="w-12 text-center">{t.wins}-{t.losses}</span>
                      <span className="w-12 text-center text-gray-400">{t.pf}</span>
                      <span className="w-12 text-center text-gray-400">{t.pa}</span>
                      <span className={`w-12 text-right ${t.pf - t.pa > 0 ? 'text-green-400' : t.pf - t.pa < 0 ? 'text-red-400' : ''}`}>
                        {t.pf - t.pa > 0 ? '+' : ''}{t.pf - t.pa}
                      </span>
                    </div>
                  );
                })}
              </div>
              <div className="mt-2 text-xs text-gray-500 text-center">
                Top {Math.ceil(teamCount / 2)} ‚Üí Winners Bracket | Bottom {Math.floor(teamCount / 2)} ‚Üí Losers Bracket
              </div>
              {allSeedingComplete && (
                <button onClick={() => setPhase('bracket')} className="w-full mt-4 bg-green-600 py-2 rounded font-semibold">
                  Start Bracket ‚Üí
                </button>
              )}
            </div>
          )}

          {phase === 'bracket' && (
            <div className="max-w-6xl mx-auto overflow-x-auto">
              {!spectatorMode && <CourtStatus onCourtMatches={onCourtMatches} nextUpMatches={nextUpMatches} onToggleCourt={toggleOnCourt} />}

              {bracketSwaps.length > 0 && (
                <div className="mb-3 bg-yellow-900/50 border border-yellow-600 rounded p-2 text-sm">
                  <div className="font-semibold text-yellow-400 mb-1">üîÑ Seeding Adjusted (No Pool Rematches in R1)</div>
                  {bracketSwaps.map((swap, i) => (
                    <div key={i} className="text-yellow-200 text-xs">{swap}</div>
                  ))}
                </div>
              )}

              <div className="flex justify-between items-center mb-2">
                <h2 className="text-lg font-semibold text-blue-400">Winners Bracket</h2>
                {!spectatorMode && (
                  <div className="flex items-center gap-3">
                    <button onClick={generateFakeBracketScores} className="text-xs bg-purple-700 hover:bg-purple-600 px-2 py-1 rounded">üé≤ Test Scores</button>
                    <label className="text-xs text-gray-500 flex items-center gap-1">
                      <input type="checkbox" checked={showOverride} onChange={(e) => setShowOverride(e.target.checked)} />
                      Override
                    </label>
                  </div>
                )}
              </div>

              <div className="flex gap-3 pb-4">
                <div className="space-y-2 w-44 flex-shrink-0">
                  <div className="text-xs text-gray-500 text-center">W-QF</div>
                  {['wqf1', 'wqf2', 'wqf3', 'wqf4'].map(id => (
                    <BracketMatch
                      key={id}
                      match={bracketMatches[id]}
                      score={bracketScores[id] || {}}
                      override={bracketOverrides[id]}
                      isOnCourt={onCourt[id]}
                      showOverride={showOverride}
                      onScoreChange={(field, value) => handleBracketScore(id, bracketMatches[id]?.t1, bracketMatches[id]?.t2, field, value)}
                      onToggleCourt={() => toggleOnCourt(id)}
                      onOverride={(team) => handleBracketOverride(id, team, team === bracketMatches[id]?.t1 ? bracketMatches[id]?.t2 : bracketMatches[id]?.t1)}
                      onClearOverride={() => clearBracketOverride(id)}
                      winner={getBracketMatchTeam(id)}
                      readOnly={spectatorMode}
                    />
                  ))}
                </div>
                <div className="space-y-2 w-44 flex-shrink-0 pt-10">
                  <div className="text-xs text-gray-500 text-center">W-SF</div>
                  {['wsf1', 'wsf2'].map((id, idx) => (
                    <React.Fragment key={id}>
                      <BracketMatch
                        match={bracketMatches[id]}
                        score={bracketScores[id] || {}}
                        override={bracketOverrides[id]}
                        isOnCourt={onCourt[id]}
                        showOverride={showOverride}
                        onScoreChange={(field, value) => handleBracketScore(id, bracketMatches[id]?.t1, bracketMatches[id]?.t2, field, value)}
                        onToggleCourt={() => toggleOnCourt(id)}
                        onOverride={(team) => handleBracketOverride(id, team, team === bracketMatches[id]?.t1 ? bracketMatches[id]?.t2 : bracketMatches[id]?.t1)}
                        onClearOverride={() => clearBracketOverride(id)}
                        winner={getBracketMatchTeam(id)}
                        readOnly={spectatorMode}
                      />
                      {idx === 0 && <div className="h-12"></div>}
                    </React.Fragment>
                  ))}
                </div>
                <div className="w-44 flex-shrink-0 pt-20">
                  <div className="text-xs text-gray-500 text-center">W-Final</div>
                  <BracketMatch
                    match={bracketMatches.wf}
                    score={bracketScores.wf || {}}
                    override={bracketOverrides.wf}
                    isOnCourt={onCourt.wf}
                    showOverride={showOverride}
                    onScoreChange={(field, value) => handleBracketScore('wf', bracketMatches.wf?.t1, bracketMatches.wf?.t2, field, value)}
                    onToggleCourt={() => toggleOnCourt('wf')}
                    onOverride={(team) => handleBracketOverride('wf', team, team === bracketMatches.wf?.t1 ? bracketMatches.wf?.t2 : bracketMatches.wf?.t1)}
                    onClearOverride={() => clearBracketOverride('wf')}
                    winner={getBracketMatchTeam('wf')}
                    readOnly={spectatorMode}
                  />
                </div>
                <div className="w-56 flex-shrink-0 pt-16">
                  <h3 className="text-yellow-400 font-semibold mb-2 text-center text-sm">üèÜ Grand Final</h3>
                  <BracketMatch
                    match={bracketMatches.gf}
                    score={bracketScores.gf || {}}
                    override={bracketOverrides.gf}
                    isOnCourt={onCourt.gf}
                    showOverride={showOverride}
                    onScoreChange={(field, value) => handleBracketScore('gf', bracketMatches.gf?.t1, bracketMatches.gf?.t2, field, value)}
                    onToggleCourt={() => toggleOnCourt('gf')}
                    onOverride={(team) => handleBracketOverride('gf', team, team === bracketMatches.gf?.t1 ? bracketMatches.gf?.t2 : bracketMatches.gf?.t1)}
                    onClearOverride={() => clearBracketOverride('gf')}
                    winner={gfWinner}
                    readOnly={spectatorMode}
                  />
                  {gfWinner && (
                    <div className="mt-3 bg-gradient-to-r from-yellow-700 to-yellow-600 p-3 rounded text-center border-2 border-yellow-400">
                      <div className="text-xs text-yellow-200">ü•á CHAMPION (${currentPayouts.first})</div>
                      {gfWinner.name.split(' / ').map((p, i) => (
                        <div key={i} className="text-sm font-bold text-white">{p}</div>
                      ))}
                    </div>
                  )}
                  {getBracketMatchLoser('gf') && (
                    <div className="mt-2 bg-gradient-to-r from-gray-500 to-gray-400 p-2 rounded text-center border border-gray-300">
                      <div className="text-xs text-gray-200">ü•à 2nd (${currentPayouts.second})</div>
                      {getBracketMatchLoser('gf').name.split(' / ').map((p, i) => (
                        <div key={i} className="text-xs font-semibold text-white">{p}</div>
                      ))}
                    </div>
                  )}
                </div>
              </div>

              <h2 className="text-lg font-semibold text-red-400 mb-2">Losers Bracket</h2>
              <div className="flex gap-3 pb-4 overflow-x-auto">
                <div className="space-y-2 w-44 flex-shrink-0">
                  <div className="text-xs text-gray-500 text-center">L-R1</div>
                  {['lr1m1', 'lr1m2', 'lr1m3', 'lr1m4'].map(id => (
                    <BracketMatch
                      key={id}
                      match={bracketMatches[id]}
                      score={bracketScores[id] || {}}
                      override={bracketOverrides[id]}
                      isOnCourt={onCourt[id]}
                      showOverride={showOverride}
                      onScoreChange={(field, value) => handleBracketScore(id, bracketMatches[id]?.t1, bracketMatches[id]?.t2, field, value)}
                      onToggleCourt={() => toggleOnCourt(id)}
                      onOverride={(team) => handleBracketOverride(id, team, team === bracketMatches[id]?.t1 ? bracketMatches[id]?.t2 : bracketMatches[id]?.t1)}
                      onClearOverride={() => clearBracketOverride(id)}
                      winner={getBracketMatchTeam(id)}
                      readOnly={spectatorMode}
                    />
                  ))}
                </div>
                <div className="space-y-2 w-44 flex-shrink-0">
                  <div className="text-xs text-gray-500 text-center">L-R2</div>
                  {['lr2m1', 'lr2m2', 'lr2m3', 'lr2m4'].map(id => (
                    <BracketMatch
                      key={id}
                      match={bracketMatches[id]}
                      score={bracketScores[id] || {}}
                      override={bracketOverrides[id]}
                      isOnCourt={onCourt[id]}
                      showOverride={showOverride}
                      onScoreChange={(field, value) => handleBracketScore(id, bracketMatches[id]?.t1, bracketMatches[id]?.t2, field, value)}
                      onToggleCourt={() => toggleOnCourt(id)}
                      onOverride={(team) => handleBracketOverride(id, team, team === bracketMatches[id]?.t1 ? bracketMatches[id]?.t2 : bracketMatches[id]?.t1)}
                      onClearOverride={() => clearBracketOverride(id)}
                      winner={getBracketMatchTeam(id)}
                      readOnly={spectatorMode}
                    />
                  ))}
                </div>
                <div className="space-y-2 w-44 flex-shrink-0 pt-10">
                  <div className="text-xs text-gray-500 text-center">L-R3</div>
                  {['lr3m1', 'lr3m2'].map((id, idx) => (
                    <React.Fragment key={id}>
                      <BracketMatch
                        match={bracketMatches[id]}
                        score={bracketScores[id] || {}}
                        override={bracketOverrides[id]}
                        isOnCourt={onCourt[id]}
                        showOverride={showOverride}
                        onScoreChange={(field, value) => handleBracketScore(id, bracketMatches[id]?.t1, bracketMatches[id]?.t2, field, value)}
                        onToggleCourt={() => toggleOnCourt(id)}
                        onOverride={(team) => handleBracketOverride(id, team, team === bracketMatches[id]?.t1 ? bracketMatches[id]?.t2 : bracketMatches[id]?.t1)}
                        onClearOverride={() => clearBracketOverride(id)}
                        winner={getBracketMatchTeam(id)}
                        readOnly={spectatorMode}
                      />
                      {idx === 0 && <div className="h-6"></div>}
                    </React.Fragment>
                  ))}
                </div>
                <div className="space-y-2 w-44 flex-shrink-0 pt-10">
                  <div className="text-xs text-gray-500 text-center">L-R4</div>
                  {['lr4m1', 'lr4m2'].map((id, idx) => (
                    <React.Fragment key={id}>
                      <BracketMatch
                        match={bracketMatches[id]}
                        score={bracketScores[id] || {}}
                        override={bracketOverrides[id]}
                        isOnCourt={onCourt[id]}
                        showOverride={showOverride}
                        onScoreChange={(field, value) => handleBracketScore(id, bracketMatches[id]?.t1, bracketMatches[id]?.t2, field, value)}
                        onToggleCourt={() => toggleOnCourt(id)}
                        onOverride={(team) => handleBracketOverride(id, team, team === bracketMatches[id]?.t1 ? bracketMatches[id]?.t2 : bracketMatches[id]?.t1)}
                        onClearOverride={() => clearBracketOverride(id)}
                        winner={getBracketMatchTeam(id)}
                        readOnly={spectatorMode}
                      />
                      {idx === 0 && <div className="h-6"></div>}
                    </React.Fragment>
                  ))}
                </div>
                <div className="w-44 flex-shrink-0 pt-14">
                  <div className="text-xs text-gray-500 text-center">L-Semi</div>
                  <BracketMatch
                    match={bracketMatches.lsf}
                    score={bracketScores.lsf || {}}
                    override={bracketOverrides.lsf}
                    isOnCourt={onCourt.lsf}
                    showOverride={showOverride}
                    onScoreChange={(field, value) => handleBracketScore('lsf', bracketMatches.lsf?.t1, bracketMatches.lsf?.t2, field, value)}
                    onToggleCourt={() => toggleOnCourt('lsf')}
                    onOverride={(team) => handleBracketOverride('lsf', team, team === bracketMatches.lsf?.t1 ? bracketMatches.lsf?.t2 : bracketMatches.lsf?.t1)}
                    onClearOverride={() => clearBracketOverride('lsf')}
                    winner={getBracketMatchTeam('lsf')}
                    readOnly={spectatorMode}
                  />
                </div>
                <div className="w-44 flex-shrink-0 pt-14">
                  <div className="text-xs text-gray-500 text-center">L-Final</div>
                  <BracketMatch
                    match={bracketMatches.lf}
                    score={bracketScores.lf || {}}
                    override={bracketOverrides.lf}
                    isOnCourt={onCourt.lf}
                    showOverride={showOverride}
                    onScoreChange={(field, value) => handleBracketScore('lf', bracketMatches.lf?.t1, bracketMatches.lf?.t2, field, value)}
                    onToggleCourt={() => toggleOnCourt('lf')}
                    onOverride={(team) => handleBracketOverride('lf', team, team === bracketMatches.lf?.t1 ? bracketMatches.lf?.t2 : bracketMatches.lf?.t1)}
                    onClearOverride={() => clearBracketOverride('lf')}
                    winner={getBracketMatchTeam('lf')}
                    readOnly={spectatorMode}
                  />
                  {getBracketMatchTeam('lf') && (
                    <div className="mt-2 text-center">
                      <div className="text-xs text-yellow-400">‚Üó to Grand Final</div>
                    </div>
                  )}
                  {getBracketMatchLoser('lf') && (
                    <div className="mt-2 bg-gradient-to-r from-amber-800 to-amber-700 p-2 rounded text-center border border-amber-500">
                      <div className="text-xs text-amber-200">ü•â 3rd Place (${currentPayouts.third})</div>
                      {getBracketMatchLoser('lf').name.split(' / ').map((p, i) => (
                        <div key={i} className="text-xs font-semibold text-white">{p}</div>
                      ))}
                    </div>
                  )}
                </div>
              </div>
            </div>
          )}

          {phase === 'results' && (
            <div className="max-w-2xl mx-auto">
              <h2 className="text-2xl font-bold text-center mb-6">üèÜ Final Results</h2>

              <div className="space-y-4">
                {gfWinner && (
                  <div className="bg-gradient-to-r from-yellow-700 to-yellow-600 p-6 rounded-lg border-2 border-yellow-400 text-center">
                    <div className="text-lg text-yellow-200">ü•á 1st Place - ${currentPayouts.first}</div>
                    {gfWinner.name.split(' / ').map((p, i) => (
                      <div key={i} className="text-2xl font-bold text-white">{p}</div>
                    ))}
                  </div>
                )}

                {getBracketMatchLoser('gf') && (
                  <div className="bg-gradient-to-r from-gray-500 to-gray-400 p-5 rounded-lg border-2 border-gray-300 text-center">
                    <div className="text-md text-gray-200">ü•à 2nd Place - ${currentPayouts.second}</div>
                    {getBracketMatchLoser('gf').name.split(' / ').map((p, i) => (
                      <div key={i} className="text-xl font-bold text-white">{p}</div>
                    ))}
                  </div>
                )}

                {getBracketMatchLoser('lf') && currentPayouts.third > 0 && (
                  <div className="bg-gradient-to-r from-amber-800 to-amber-700 p-4 rounded-lg border-2 border-amber-500 text-center">
                    <div className="text-sm text-amber-200">ü•â 3rd Place - ${currentPayouts.third}</div>
                    {getBracketMatchLoser('lf').name.split(' / ').map((p, i) => (
                      <div key={i} className="text-lg font-bold text-white">{p}</div>
                    ))}
                  </div>
                )}
              </div>

              <div className="mt-8 text-center">
                <button onClick={downloadResults} className="bg-green-600 hover:bg-green-500 px-6 py-3 rounded-lg text-lg font-semibold">
                  üì• Download Full Results
                </button>
              </div>

            </div>
          )}
        </div>
      );
    }

    ReactDOM.createRoot(document.getElementById('root')).render(<App />);
  </script>
</body>
</html>
